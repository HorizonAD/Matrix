// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "common.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace CommonProto {

namespace {

const ::google::protobuf::Descriptor* Point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Point_reflection_ = NULL;
const ::google::protobuf::Descriptor* PointI_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PointI_reflection_ = NULL;
const ::google::protobuf::Descriptor* Contour_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Contour_reflection_ = NULL;
const ::google::protobuf::Descriptor* Polygon_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Polygon_reflection_ = NULL;
const ::google::protobuf::Descriptor* Rect_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Rect_reflection_ = NULL;
const ::google::protobuf::Descriptor* OBBox2D_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OBBox2D_reflection_ = NULL;
const ::google::protobuf::Descriptor* Box3D_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Box3D_reflection_ = NULL;
const ::google::protobuf::Descriptor* SkeletonPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SkeletonPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* Image_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_reflection_ = NULL;
const ::google::protobuf::Descriptor* Velocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Velocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Line_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Line_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Line_EndPointType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Lines_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Lines_reflection_ = NULL;
const ::google::protobuf::Descriptor* WorldSpaceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WorldSpaceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImageSpaceInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImageSpaceInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Obstacle_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Obstacle_reflection_ = NULL;
const ::google::protobuf::Descriptor* Obstacles_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Obstacles_reflection_ = NULL;
const ::google::protobuf::Descriptor* FeatureMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FeatureMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* ObstacleRaw_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ObstacleRaw_reflection_ = NULL;
const ::google::protobuf::Descriptor* ObstacleRaws_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ObstacleRaws_reflection_ = NULL;
const ::google::protobuf::Descriptor* FreeSpacePoints_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FreeSpacePoints_reflection_ = NULL;
const ::google::protobuf::Descriptor* Box3DRaw_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Box3DRaw_reflection_ = NULL;
const ::google::protobuf::Descriptor* Box3DRaws_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Box3DRaws_reflection_ = NULL;
const ::google::protobuf::Descriptor* Skeleton_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Skeleton_reflection_ = NULL;
const ::google::protobuf::Descriptor* SkeletonRaw_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SkeletonRaw_reflection_ = NULL;
const ::google::protobuf::Descriptor* SkeletonRaws_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SkeletonRaws_reflection_ = NULL;
const ::google::protobuf::Descriptor* CameraMatrix_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CameraMatrix_reflection_ = NULL;
const ::google::protobuf::Descriptor* DistortParam_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DistortParam_reflection_ = NULL;
const ::google::protobuf::Descriptor* VCSParam_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VCSParam_reflection_ = NULL;
const ::google::protobuf::Descriptor* CameraParam_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CameraParam_reflection_ = NULL;
const ::google::protobuf::Descriptor* MotionFrame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MotionFrame_reflection_ = NULL;
const ::google::protobuf::Descriptor* OdometryFrame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OdometryFrame_reflection_ = NULL;
const ::google::protobuf::Descriptor* SerializedData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SerializedData_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataDescriptor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataDescriptor_reflection_ = NULL;
const ::google::protobuf::Descriptor* Color_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Color_reflection_ = NULL;
const ::google::protobuf::Descriptor* ParsingSetting_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ParsingSetting_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SkeletonType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ParsingFormat_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* LineType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ObstacleType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficLightStyle_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficLightStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficSignType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ParkingSlotStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* VehProperty_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* VehPropertyPerceptionType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficLightProperty_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficSignProperty_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RoadSignProperty_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ObstacleRawModelType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* LanePosition_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* FreeSpacePointType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CameraType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CameraVersion_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CalibrationStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* DataType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PasringLableType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_common_2eproto() {
  protobuf_AddDesc_common_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "common.proto");
  GOOGLE_CHECK(file != NULL);
  Point_descriptor_ = file->message_type(0);
  static const int Point_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, z_),
  };
  Point_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Point_descriptor_,
      Point::default_instance_,
      Point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Point, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Point));
  PointI_descriptor_ = file->message_type(1);
  static const int PointI_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointI, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointI, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointI, z_),
  };
  PointI_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PointI_descriptor_,
      PointI::default_instance_,
      PointI_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointI, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PointI, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PointI));
  Contour_descriptor_ = file->message_type(2);
  static const int Contour_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Contour, pts_),
  };
  Contour_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Contour_descriptor_,
      Contour::default_instance_,
      Contour_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Contour, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Contour, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Contour));
  Polygon_descriptor_ = file->message_type(3);
  static const int Polygon_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, pts_),
  };
  Polygon_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Polygon_descriptor_,
      Polygon::default_instance_,
      Polygon_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Polygon, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Polygon));
  Rect_descriptor_ = file->message_type(4);
  static const int Rect_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, top_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, bottom_),
  };
  Rect_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Rect_descriptor_,
      Rect::default_instance_,
      Rect_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Rect));
  OBBox2D_descriptor_ = file->message_type(5);
  static const int OBBox2D_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OBBox2D, corner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OBBox2D, axes_pts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OBBox2D, size_),
  };
  OBBox2D_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OBBox2D_descriptor_,
      OBBox2D::default_instance_,
      OBBox2D_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OBBox2D, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OBBox2D, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OBBox2D));
  Box3D_descriptor_ = file->message_type(6);
  static const int Box3D_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, lower_lt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, lower_lb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, lower_rb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, lower_rt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, upper_lt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, upper_lb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, upper_rb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, upper_rt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, conf_),
  };
  Box3D_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Box3D_descriptor_,
      Box3D::default_instance_,
      Box3D_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3D, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Box3D));
  SkeletonPoint_descriptor_ = file->message_type(7);
  static const int SkeletonPoint_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonPoint, pt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonPoint, valid_),
  };
  SkeletonPoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SkeletonPoint_descriptor_,
      SkeletonPoint::default_instance_,
      SkeletonPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonPoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonPoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SkeletonPoint));
  Image_descriptor_ = file->message_type(8);
  static const int Image_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, send_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, format_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, depth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, align_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, image_counter_),
  };
  Image_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Image_descriptor_,
      Image::default_instance_,
      Image_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Image));
  Velocity_descriptor_ = file->message_type(9);
  static const int Velocity_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, vx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, vy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, vz_),
  };
  Velocity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Velocity_descriptor_,
      Velocity::default_instance_,
      Velocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Velocity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Velocity));
  Line_descriptor_ = file->message_type(10);
  static const int Line_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, life_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, coeffs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, end_points_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, contours_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, dist_to_front_wheel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, type_sibling_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, conf_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, sigma_coeffs_),
  };
  Line_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Line_descriptor_,
      Line::default_instance_,
      Line_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Line));
  Line_EndPointType_descriptor_ = Line_descriptor_->enum_type(0);
  Lines_descriptor_ = file->message_type(11);
  static const int Lines_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lines, cam_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lines, lines_),
  };
  Lines_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Lines_descriptor_,
      Lines::default_instance_,
      Lines_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lines, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lines, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Lines));
  WorldSpaceInfo_descriptor_ = file->message_type(12);
  static const int WorldSpaceInfo_offsets_[17] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, yaw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, vel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, poly_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, traversable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, hmw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, ttc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, curr_lane_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, position_obs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, sigma_yaw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, sigma_vel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, sigma_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, sigma_height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, sigma_position_),
  };
  WorldSpaceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WorldSpaceInfo_descriptor_,
      WorldSpaceInfo::default_instance_,
      WorldSpaceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldSpaceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WorldSpaceInfo));
  ImageSpaceInfo_descriptor_ = file->message_type(13);
  static const int ImageSpaceInfo_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, rect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, skeleton_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, box_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, poly_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, sigma_width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, sigma_height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, sigma_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, sigma_y_),
  };
  ImageSpaceInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImageSpaceInfo_descriptor_,
      ImageSpaceInfo::default_instance_,
      ImageSpaceInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageSpaceInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImageSpaceInfo));
  Obstacle_descriptor_ = file->message_type(14);
  static const int Obstacle_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, conf_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, life_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, age_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, img_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, world_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, property_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, property_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, property_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, property_conf_),
  };
  Obstacle_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Obstacle_descriptor_,
      Obstacle::default_instance_,
      Obstacle_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacle, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Obstacle));
  Obstacles_descriptor_ = file->message_type(15);
  static const int Obstacles_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, cam_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, obstacle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, conf_scale_),
  };
  Obstacles_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Obstacles_descriptor_,
      Obstacles::default_instance_,
      Obstacles_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Obstacles, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Obstacles));
  FeatureMap_descriptor_ = file->message_type(16);
  static const int FeatureMap_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureMap, data_),
  };
  FeatureMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FeatureMap_descriptor_,
      FeatureMap::default_instance_,
      FeatureMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FeatureMap));
  ObstacleRaw_descriptor_ = file->message_type(17);
  static const int ObstacleRaw_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, rect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, conf_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, property_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, property_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, property_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, property_conf_),
  };
  ObstacleRaw_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ObstacleRaw_descriptor_,
      ObstacleRaw::default_instance_,
      ObstacleRaw_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaw, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ObstacleRaw));
  ObstacleRaws_descriptor_ = file->message_type(18);
  static const int ObstacleRaws_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaws, cam_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaws, obstacle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaws, conf_scale_),
  };
  ObstacleRaws_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ObstacleRaws_descriptor_,
      ObstacleRaws::default_instance_,
      ObstacleRaws_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaws, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ObstacleRaws, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ObstacleRaws));
  FreeSpacePoints_descriptor_ = file->message_type(19);
  static const int FreeSpacePoints_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FreeSpacePoints, property_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FreeSpacePoints, cam_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FreeSpacePoints, pts_vcs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FreeSpacePoints, pts_img_),
  };
  FreeSpacePoints_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FreeSpacePoints_descriptor_,
      FreeSpacePoints::default_instance_,
      FreeSpacePoints_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FreeSpacePoints, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FreeSpacePoints, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FreeSpacePoints));
  Box3DRaw_descriptor_ = file->message_type(20);
  static const int Box3DRaw_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3DRaw, percept_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3DRaw, box_),
  };
  Box3DRaw_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Box3DRaw_descriptor_,
      Box3DRaw::default_instance_,
      Box3DRaw_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3DRaw, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3DRaw, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Box3DRaw));
  Box3DRaws_descriptor_ = file->message_type(21);
  static const int Box3DRaws_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3DRaws, cam_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3DRaws, box_3d_),
  };
  Box3DRaws_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Box3DRaws_descriptor_,
      Box3DRaws::default_instance_,
      Box3DRaws_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3DRaws, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Box3DRaws, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Box3DRaws));
  Skeleton_descriptor_ = file->message_type(22);
  static const int Skeleton_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Skeleton, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Skeleton, skeleton_),
  };
  Skeleton_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Skeleton_descriptor_,
      Skeleton::default_instance_,
      Skeleton_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Skeleton, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Skeleton, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Skeleton));
  SkeletonRaw_descriptor_ = file->message_type(23);
  static const int SkeletonRaw_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonRaw, percept_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonRaw, skeleton_),
  };
  SkeletonRaw_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SkeletonRaw_descriptor_,
      SkeletonRaw::default_instance_,
      SkeletonRaw_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonRaw, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonRaw, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SkeletonRaw));
  SkeletonRaws_descriptor_ = file->message_type(24);
  static const int SkeletonRaws_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonRaws, cam_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonRaws, skeleton_raw_),
  };
  SkeletonRaws_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SkeletonRaws_descriptor_,
      SkeletonRaws::default_instance_,
      SkeletonRaws_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonRaws, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SkeletonRaws, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SkeletonRaws));
  CameraMatrix_descriptor_ = file->message_type(25);
  static const int CameraMatrix_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraMatrix, mat_gnd2img_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraMatrix, mat_img2gnd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraMatrix, mat_vcsgnd2img_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraMatrix, mat_img2vcsgnd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraMatrix, mat_local2img_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraMatrix, mat_img2local_),
  };
  CameraMatrix_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CameraMatrix_descriptor_,
      CameraMatrix::default_instance_,
      CameraMatrix_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraMatrix, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraMatrix, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CameraMatrix));
  DistortParam_descriptor_ = file->message_type(26);
  static const int DistortParam_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DistortParam, param_),
  };
  DistortParam_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DistortParam_descriptor_,
      DistortParam::default_instance_,
      DistortParam_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DistortParam, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DistortParam, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DistortParam));
  VCSParam_descriptor_ = file->message_type(27);
  static const int VCSParam_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VCSParam, rotation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VCSParam, translation_),
  };
  VCSParam_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VCSParam_descriptor_,
      VCSParam::default_instance_,
      VCSParam_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VCSParam, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VCSParam, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VCSParam));
  CameraParam_descriptor_ = file->message_type(28);
  static const int CameraParam_offsets_[18] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, focal_u_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, focal_v_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, center_u_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, center_v_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, camera_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, camera_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, camera_z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, pitch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, yaw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, roll_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, fov_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, cali_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, distort_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, vcs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, mat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, vendor_),
  };
  CameraParam_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CameraParam_descriptor_,
      CameraParam::default_instance_,
      CameraParam_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraParam, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CameraParam));
  MotionFrame_descriptor_ = file->message_type(29);
  static const int MotionFrame_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotionFrame, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotionFrame, acc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotionFrame, yaw_rate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotionFrame, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotionFrame, turning_radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotionFrame, is_stable_),
  };
  MotionFrame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MotionFrame_descriptor_,
      MotionFrame::default_instance_,
      MotionFrame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotionFrame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotionFrame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MotionFrame));
  OdometryFrame_descriptor_ = file->message_type(30);
  static const int OdometryFrame_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OdometryFrame, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OdometryFrame, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OdometryFrame, yaw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OdometryFrame, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OdometryFrame, yaw_rate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OdometryFrame, time_stamp_),
  };
  OdometryFrame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OdometryFrame_descriptor_,
      OdometryFrame::default_instance_,
      OdometryFrame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OdometryFrame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OdometryFrame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OdometryFrame));
  SerializedData_descriptor_ = file->message_type(31);
  static const int SerializedData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerializedData, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerializedData, proto_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerializedData, channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerializedData, with_data_field_),
  };
  SerializedData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SerializedData_descriptor_,
      SerializedData::default_instance_,
      SerializedData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerializedData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SerializedData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SerializedData));
  DataDescriptor_descriptor_ = file->message_type(32);
  static const int DataDescriptor_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescriptor, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescriptor, data_),
  };
  DataDescriptor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataDescriptor_descriptor_,
      DataDescriptor::default_instance_,
      DataDescriptor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescriptor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataDescriptor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataDescriptor));
  Color_descriptor_ = file->message_type(33);
  static const int Color_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, b_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, g_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, r_),
  };
  Color_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Color_descriptor_,
      Color::default_instance_,
      Color_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Color));
  ParsingSetting_descriptor_ = file->message_type(34);
  static const int ParsingSetting_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParsingSetting, parsing_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParsingSetting, parsing_channels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParsingSetting, channel_labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParsingSetting, channel_colors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParsingSetting, freespace_channels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParsingSetting, boundspace_channels_),
  };
  ParsingSetting_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ParsingSetting_descriptor_,
      ParsingSetting::default_instance_,
      ParsingSetting_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParsingSetting, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParsingSetting, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ParsingSetting));
  SkeletonType_descriptor_ = file->enum_type(0);
  ImageFormat_descriptor_ = file->enum_type(1);
  ParsingFormat_descriptor_ = file->enum_type(2);
  LineType_descriptor_ = file->enum_type(3);
  ObstacleType_descriptor_ = file->enum_type(4);
  TrafficLightStyle_descriptor_ = file->enum_type(5);
  TrafficLightStatus_descriptor_ = file->enum_type(6);
  TrafficSignType_descriptor_ = file->enum_type(7);
  ParkingSlotStatus_descriptor_ = file->enum_type(8);
  VehProperty_descriptor_ = file->enum_type(9);
  VehPropertyPerceptionType_descriptor_ = file->enum_type(10);
  TrafficLightProperty_descriptor_ = file->enum_type(11);
  TrafficSignProperty_descriptor_ = file->enum_type(12);
  RoadSignProperty_descriptor_ = file->enum_type(13);
  ObstacleRawModelType_descriptor_ = file->enum_type(14);
  LanePosition_descriptor_ = file->enum_type(15);
  FreeSpacePointType_descriptor_ = file->enum_type(16);
  CameraType_descriptor_ = file->enum_type(17);
  CameraVersion_descriptor_ = file->enum_type(18);
  CalibrationStatus_descriptor_ = file->enum_type(19);
  DataType_descriptor_ = file->enum_type(20);
  PasringLableType_descriptor_ = file->enum_type(21);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_common_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Point_descriptor_, &Point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PointI_descriptor_, &PointI::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Contour_descriptor_, &Contour::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Polygon_descriptor_, &Polygon::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Rect_descriptor_, &Rect::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OBBox2D_descriptor_, &OBBox2D::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Box3D_descriptor_, &Box3D::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SkeletonPoint_descriptor_, &SkeletonPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Image_descriptor_, &Image::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Velocity_descriptor_, &Velocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Line_descriptor_, &Line::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Lines_descriptor_, &Lines::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WorldSpaceInfo_descriptor_, &WorldSpaceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImageSpaceInfo_descriptor_, &ImageSpaceInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Obstacle_descriptor_, &Obstacle::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Obstacles_descriptor_, &Obstacles::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FeatureMap_descriptor_, &FeatureMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ObstacleRaw_descriptor_, &ObstacleRaw::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ObstacleRaws_descriptor_, &ObstacleRaws::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FreeSpacePoints_descriptor_, &FreeSpacePoints::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Box3DRaw_descriptor_, &Box3DRaw::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Box3DRaws_descriptor_, &Box3DRaws::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Skeleton_descriptor_, &Skeleton::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SkeletonRaw_descriptor_, &SkeletonRaw::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SkeletonRaws_descriptor_, &SkeletonRaws::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CameraMatrix_descriptor_, &CameraMatrix::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DistortParam_descriptor_, &DistortParam::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VCSParam_descriptor_, &VCSParam::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CameraParam_descriptor_, &CameraParam::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MotionFrame_descriptor_, &MotionFrame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OdometryFrame_descriptor_, &OdometryFrame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SerializedData_descriptor_, &SerializedData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataDescriptor_descriptor_, &DataDescriptor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Color_descriptor_, &Color::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ParsingSetting_descriptor_, &ParsingSetting::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_common_2eproto() {
  delete Point::default_instance_;
  delete Point_reflection_;
  delete PointI::default_instance_;
  delete PointI_reflection_;
  delete Contour::default_instance_;
  delete Contour_reflection_;
  delete Polygon::default_instance_;
  delete Polygon_reflection_;
  delete Rect::default_instance_;
  delete Rect_reflection_;
  delete OBBox2D::default_instance_;
  delete OBBox2D_reflection_;
  delete Box3D::default_instance_;
  delete Box3D_reflection_;
  delete SkeletonPoint::default_instance_;
  delete SkeletonPoint_reflection_;
  delete Image::default_instance_;
  delete Image_reflection_;
  delete Velocity::default_instance_;
  delete Velocity_reflection_;
  delete Line::default_instance_;
  delete Line_reflection_;
  delete Lines::default_instance_;
  delete Lines_reflection_;
  delete WorldSpaceInfo::default_instance_;
  delete WorldSpaceInfo_reflection_;
  delete ImageSpaceInfo::default_instance_;
  delete ImageSpaceInfo_reflection_;
  delete Obstacle::default_instance_;
  delete Obstacle_reflection_;
  delete Obstacles::default_instance_;
  delete Obstacles_reflection_;
  delete FeatureMap::default_instance_;
  delete FeatureMap_reflection_;
  delete ObstacleRaw::default_instance_;
  delete ObstacleRaw_reflection_;
  delete ObstacleRaws::default_instance_;
  delete ObstacleRaws_reflection_;
  delete FreeSpacePoints::default_instance_;
  delete FreeSpacePoints_reflection_;
  delete Box3DRaw::default_instance_;
  delete Box3DRaw_reflection_;
  delete Box3DRaws::default_instance_;
  delete Box3DRaws_reflection_;
  delete Skeleton::default_instance_;
  delete Skeleton_reflection_;
  delete SkeletonRaw::default_instance_;
  delete SkeletonRaw_reflection_;
  delete SkeletonRaws::default_instance_;
  delete SkeletonRaws_reflection_;
  delete CameraMatrix::default_instance_;
  delete CameraMatrix_reflection_;
  delete DistortParam::default_instance_;
  delete DistortParam_reflection_;
  delete VCSParam::default_instance_;
  delete VCSParam_reflection_;
  delete CameraParam::default_instance_;
  delete CameraParam_reflection_;
  delete MotionFrame::default_instance_;
  delete MotionFrame_reflection_;
  delete OdometryFrame::default_instance_;
  delete OdometryFrame_reflection_;
  delete SerializedData::default_instance_;
  delete SerializedData_reflection_;
  delete DataDescriptor::default_instance_;
  delete DataDescriptor_reflection_;
  delete Color::default_instance_;
  delete Color_reflection_;
  delete ParsingSetting::default_instance_;
  delete ParsingSetting_reflection_;
}

void protobuf_AddDesc_common_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014common.proto\022\013CommonProto\"(\n\005Point\022\t\n\001"
    "x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \001(\002\")\n\006PointI\022"
    "\t\n\001x\030\001 \002(\005\022\t\n\001y\030\002 \002(\005\022\t\n\001z\030\003 \001(\005\"*\n\007Cont"
    "our\022\037\n\003pts\030\001 \003(\0132\022.CommonProto.Point\"*\n\007"
    "Polygon\022\037\n\003pts\030\001 \003(\0132\022.CommonProto.Point"
    "\"@\n\004Rect\022\014\n\004left\030\001 \002(\002\022\013\n\003top\030\002 \002(\002\022\r\n\005r"
    "ight\030\003 \002(\002\022\016\n\006bottom\030\004 \002(\002\"a\n\007OBBox2D\022\"\n"
    "\006corner\030\001 \002(\0132\022.CommonProto.Point\022$\n\010axe"
    "s_pts\030\002 \003(\0132\022.CommonProto.Point\022\014\n\004size\030"
    "\003 \003(\002\"\305\002\n\005Box3D\022$\n\010lower_lt\030\001 \002(\0132\022.Comm"
    "onProto.Point\022$\n\010lower_lb\030\002 \002(\0132\022.Common"
    "Proto.Point\022$\n\010lower_rb\030\003 \002(\0132\022.CommonPr"
    "oto.Point\022$\n\010lower_rt\030\004 \002(\0132\022.CommonProt"
    "o.Point\022$\n\010upper_lt\030\005 \002(\0132\022.CommonProto."
    "Point\022$\n\010upper_lb\030\006 \002(\0132\022.CommonProto.Po"
    "int\022$\n\010upper_rb\030\007 \002(\0132\022.CommonProto.Poin"
    "t\022$\n\010upper_rt\030\010 \002(\0132\022.CommonProto.Point\022"
    "\014\n\004conf\030\t \001(\002\">\n\rSkeletonPoint\022\036\n\002pt\030\001 \002"
    "(\0132\022.CommonProto.Point\022\r\n\005valid\030\002 \002(\005\"\301\001"
    "\n\005Image\022\r\n\005width\030\001 \002(\005\022\016\n\006height\030\002 \002(\005\022\017"
    "\n\007channel\030\003 \002(\005\022\022\n\ntime_stamp\030\004 \001(\003\022\021\n\ts"
    "end_mode\030\005 \001(\005\022\016\n\006format\030\006 \001(\005\022\r\n\005index\030"
    "\007 \001(\005\022\r\n\005count\030\010 \001(\005\022\r\n\005depth\030\t \001(\005\022\r\n\005a"
    "lign\030\n \001(\005\022\025\n\rimage_counter\030\013 \001(\005\".\n\010Vel"
    "ocity\022\n\n\002vx\030\001 \002(\002\022\n\n\002vy\030\002 \002(\002\022\n\n\002vz\030\003 \001("
    "\002\"\306\002\n\004Line\022\n\n\002id\030\001 \002(\005\022\021\n\tlife_time\030\003 \001("
    "\005\022\016\n\006coeffs\030\007 \003(\002\022&\n\nend_points\030\010 \003(\0132\022."
    "CommonProto.Point\022\014\n\004type\030\t \001(\005\022\016\n\006sourc"
    "e\030\n \001(\005\022&\n\010contours\030\013 \003(\0132\024.CommonProto."
    "Contour\022\033\n\023dist_to_front_wheel\030\014 \001(\002\022\r\n\005"
    "width\030\r \001(\002\022\024\n\014type_sibling\030\016 \001(\005\022\014\n\004con"
    "f\030\017 \001(\002\022\024\n\014sigma_coeffs\030\024 \003(\002\";\n\014EndPoin"
    "tType\022\024\n\020EndPointType_Far\020\000\022\025\n\021EndPointT"
    "ype_Near\020\001\"9\n\005Lines\022\016\n\006cam_id\030\001 \001(\005\022 \n\005l"
    "ines\030\002 \003(\0132\021.CommonProto.Line\"\217\003\n\016WorldS"
    "paceInfo\022\013\n\003yaw\030\001 \001(\002\022\"\n\003vel\030\002 \001(\0132\025.Com"
    "monProto.Velocity\022\016\n\006length\030\003 \001(\002\022\r\n\005wid"
    "th\030\004 \001(\002\022\016\n\006height\030\005 \001(\002\022\"\n\004poly\030\006 \001(\0132\024"
    ".CommonProto.Polygon\022$\n\010position\030\007 \001(\0132\022"
    ".CommonProto.Point\022\023\n\013traversable\030\010 \001(\005\022"
    "\013\n\003hmw\030\t \001(\002\022\013\n\003ttc\030\n \001(\002\022\021\n\tcurr_lane\030\013"
    " \001(\005\022(\n\014position_obs\030\014 \001(\0132\022.CommonProto"
    ".Point\022\021\n\tsigma_yaw\030\036 \001(\002\022\021\n\tsigma_vel\030\037"
    " \003(\002\022\023\n\013sigma_width\030  \001(\002\022\024\n\014sigma_heigh"
    "t\030! \001(\002\022\026\n\016sigma_position\030\" \003(\002\"\354\001\n\016Imag"
    "eSpaceInfo\022\037\n\004rect\030\001 \001(\0132\021.CommonProto.R"
    "ect\022\'\n\010skeleton\030\n \001(\0132\025.CommonProto.Skel"
    "eton\022\037\n\003box\030\013 \001(\0132\022.CommonProto.Box3D\022\"\n"
    "\004poly\030\014 \001(\0132\024.CommonProto.Polygon\022\023\n\013sig"
    "ma_width\030\024 \001(\002\022\024\n\014sigma_height\030\025 \001(\002\022\017\n\007"
    "sigma_x\030\026 \001(\002\022\017\n\007sigma_y\030\027 \001(\002\"\211\002\n\010Obsta"
    "cle\022\n\n\002id\030\001 \002(\005\022\014\n\004type\030\002 \002(\005\022\014\n\004conf\030\003 "
    "\001(\005\022\021\n\tlife_time\030\004 \001(\005\022\013\n\003age\030\005 \001(\005\022-\n\010i"
    "mg_info\030\006 \001(\0132\033.CommonProto.ImageSpaceIn"
    "fo\022/\n\nworld_info\030\007 \001(\0132\033.CommonProto.Wor"
    "ldSpaceInfo\022\020\n\010property\030\r \003(\005\022\025\n\rpropert"
    "y_name\030\016 \003(\t\022\025\n\rproperty_type\030\017 \003(\005\022\025\n\rp"
    "roperty_conf\030\020 \003(\002\"]\n\tObstacles\022\016\n\006cam_i"
    "d\030\001 \001(\005\022\'\n\010obstacle\030\002 \003(\0132\025.CommonProto."
    "Obstacle\022\027\n\nconf_scale\030\003 \001(\002:\0030.1\"\032\n\nFea"
    "tureMap\022\014\n\004data\030\001 \002(\014\"\262\001\n\013ObstacleRaw\022\037\n"
    "\004rect\030\001 \002(\0132\021.CommonProto.Rect\022\014\n\004conf\030\002"
    " \002(\002\022\r\n\005model\030\003 \002(\005\022\016\n\006source\030\004 \001(\005\022\020\n\010p"
    "roperty\030\006 \003(\005\022\025\n\rproperty_name\030\007 \003(\t\022\025\n\r"
    "property_type\030\010 \003(\005\022\025\n\rproperty_conf\030\t \003"
    "(\002\"c\n\014ObstacleRaws\022\016\n\006cam_id\030\001 \001(\005\022*\n\010ob"
    "stacle\030\002 \003(\0132\030.CommonProto.ObstacleRaw\022\027"
    "\n\nconf_scale\030\003 \001(\002:\0030.1\"}\n\017FreeSpacePoin"
    "ts\022\020\n\010property\030\003 \003(\005\022\016\n\006cam_id\030\004 \001(\005\022#\n\007"
    "pts_vcs\030\005 \003(\0132\022.CommonProto.Point\022#\n\007pts"
    "_img\030\006 \003(\0132\022.CommonProto.Point\"V\n\010Box3DR"
    "aw\022)\n\007percept\030\001 \002(\0132\030.CommonProto.Obstac"
    "leRaw\022\037\n\003box\030\002 \002(\0132\022.CommonProto.Box3D\"B"
    "\n\tBox3DRaws\022\016\n\006cam_id\030\001 \001(\005\022%\n\006box_3d\030\002 "
    "\003(\0132\025.CommonProto.Box3DRaw\"D\n\010Skeleton\022\n"
    "\n\002id\030\001 \001(\005\022,\n\010skeleton\030\002 \003(\0132\032.CommonPro"
    "to.SkeletonPoint\"f\n\013SkeletonRaw\022)\n\007perce"
    "pt\030\001 \002(\0132\030.CommonProto.ObstacleRaw\022,\n\010sk"
    "eleton\030\002 \003(\0132\032.CommonProto.SkeletonPoint"
    "\"N\n\014SkeletonRaws\022\016\n\006cam_id\030\001 \001(\005\022.\n\014skel"
    "eton_raw\030\002 \003(\0132\030.CommonProto.SkeletonRaw"
    "\"\226\001\n\014CameraMatrix\022\023\n\013mat_gnd2img\030\001 \003(\002\022\023"
    "\n\013mat_img2gnd\030\002 \003(\002\022\026\n\016mat_vcsgnd2img\030\003 "
    "\003(\002\022\026\n\016mat_img2vcsgnd\030\004 \003(\002\022\025\n\rmat_local"
    "2img\030\005 \003(\002\022\025\n\rmat_img2local\030\006 \003(\002\"\035\n\014Dis"
    "tortParam\022\r\n\005param\030\001 \003(\002\"1\n\010VCSParam\022\020\n\010"
    "rotation\030\001 \003(\002\022\023\n\013translation\030\002 \003(\002\"\242\003\n\013"
    "CameraParam\022\017\n\007focal_u\030\001 \002(\002\022\017\n\007focal_v\030"
    "\002 \002(\002\022\020\n\010center_u\030\003 \002(\002\022\020\n\010center_v\030\004 \002("
    "\002\022\020\n\010camera_x\030\005 \002(\002\022\020\n\010camera_y\030\006 \002(\002\022\020\n"
    "\010camera_z\030\007 \002(\002\022\r\n\005pitch\030\010 \002(\002\022\013\n\003yaw\030\t "
    "\002(\002\022\014\n\004roll\030\n \002(\002\022\017\n\004type\030\013 \001(\005:\0010\022\013\n\003fo"
    "v\030\014 \001(\002\022\022\n\007version\030\r \001(\005:\0010\0223\n\013cali_stat"
    "us\030\016 \001(\0162\036.CommonProto.CalibrationStatus"
    "\022*\n\007distort\030\024 \001(\0132\031.CommonProto.DistortP"
    "aram\022\"\n\003vcs\030\025 \001(\0132\025.CommonProto.VCSParam"
    "\022&\n\003mat\030\036 \001(\0132\031.CommonProto.CameraMatrix"
    "\022\016\n\006vendor\0302 \001(\t\"z\n\013MotionFrame\022\r\n\005speed"
    "\030\001 \002(\002\022\013\n\003acc\030\002 \001(\002\022\020\n\010yaw_rate\030\003 \002(\002\022\022\n"
    "\ntime_stamp\030\004 \002(\003\022\026\n\016turning_radius\030\005 \001("
    "\002\022\021\n\tis_stable\030\006 \001(\010\"g\n\rOdometryFrame\022\t\n"
    "\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\013\n\003yaw\030\003 \002(\002\022\r\n\005spee"
    "d\030\004 \002(\002\022\020\n\010yaw_rate\030\005 \002(\002\022\022\n\ntime_stamp\030"
    "\006 \002(\003\"`\n\016SerializedData\022\014\n\004type\030\001 \002(\t\022\r\n"
    "\005proto\030\002 \002(\014\022\022\n\007channel\030\004 \002(\005:\0010\022\035\n\017with"
    "_data_field\030\005 \002(\010:\004true\"I\n\016DataDescripto"
    "r\022\014\n\004type\030\001 \001(\t\022)\n\004data\030\002 \001(\0132\033.CommonPr"
    "oto.SerializedData\"(\n\005Color\022\t\n\001b\030\001 \002(\r\022\t"
    "\n\001g\030\002 \002(\r\022\t\n\001r\030\003 \002(\r\"\275\001\n\016ParsingSetting\022"
    "\024\n\014parsing_type\030\001 \002(\005\022\030\n\020parsing_channel"
    "s\030\002 \002(\005\022\026\n\016channel_labels\030\003 \003(\004\022*\n\016chann"
    "el_colors\030\004 \003(\0132\022.CommonProto.Color\022\032\n\022f"
    "reespace_channels\030\005 \003(\005\022\033\n\023boundspace_ch"
    "annels\030\006 \003(\005*\365\003\n\014SkeletonType\022\025\n\021Skeleto"
    "nType_nose\020\000\022\031\n\025SkeletonType_left_eye\020\001\022"
    "\032\n\026SkeletonType_right_eye\020\002\022\031\n\025SkeletonT"
    "ype_left_ear\020\003\022\032\n\026SkeletonType_right_ear"
    "\020\004\022\036\n\032SkeletonType_left_shoulder\020\005\022\037\n\033Sk"
    "eletonType_right_shoulder\020\006\022\033\n\027SkeletonT"
    "ype_left_elbow\020\007\022\034\n\030SkeletonType_right_e"
    "lbow\020\010\022\033\n\027SkeletonType_left_wrist\020\t\022\034\n\030S"
    "keletonType_right_wrist\020\n\022\031\n\025SkeletonTyp"
    "e_left_hip\020\013\022\032\n\026SkeletonType_right_hip\020\014"
    "\022\032\n\026SkeletonType_left_knee\020\r\022\033\n\027Skeleton"
    "Type_right_knee\020\016\022\033\n\027SkeletonType_left_a"
    "nkle\020\017\022\034\n\030SkeletonType_right_ankle\020\020*y\n\013"
    "ImageFormat\022\010\n\004GRAY\020\000\022\010\n\004YV12\020\001\022\010\n\004JPEG\020"
    "\002\022\007\n\003PNG\020\003\022\010\n\004CR12\020\004\022\007\n\003BAD\020\005\022\010\n\004NV12\020\006\022"
    "\010\n\004NV21\020\007\022\013\n\007TIMEOUT\020\010\022\017\n\013BYPASS_ONLY\020\t*"
    "\\\n\rParsingFormat\022\025\n\021ParsingFormat_Raw\020\000\022"
    "\027\n\023ParsingFormat_Label\020\001\022\033\n\027ParsingForma"
    "t_Label_RLE\020\002*\226\003\n\010LineType\022\r\n\tLINE_LEFT\020"
    "\001\022\016\n\nLINE_RIGHT\020\002\022\022\n\016LINE_LEFT_LEFT\020\004\022\024\n"
    "\020LINE_RIGHT_RIGHT\020\010\022\020\n\013LINE_DOUBLE\020\200\004\022\016\n"
    "\tLINE_DASH\020\200\010\022\017\n\nLINE_SOLID\020\200\020\022\017\n\nLINE_W"
    "HITE\020\200 \022\020\n\013LINE_YELLOW\020\200@\022\017\n\tLINE_BLUE\020\200"
    "\200\001\022\020\n\nLINE_GREEN\020\200\200\002\022\020\n\nLINE_FENCE\020\200\200\004\022\026"
    "\n\020LINE_ROAD_HEIGHT\020\200\200\010\022\035\n\027LINE_DIVERSION"
    "_SEPARATE\020\200\200\020\022\022\n\014LINE_BARRIER\020\200\200 \022\032\n\024LIN"
    "E_DIVERSION_MERGE\020\200\200@\022\026\n\017LINE_PERCEPTION"
    "\020\200\200\200\001\022\024\n\rLINE_TRACKING\020\200\200\200\002\022\017\n\010LINE_RAW\020"
    "\200\200\200\004\022\020\n\tLINE_ROAD\020\200\200\200\010*\367\001\n\014ObstacleType\022"
    "\034\n\030ObstacleType_VehicleRear\020\000\022\034\n\030Obstacl"
    "eType_VehicleFull\020\001\022\033\n\027ObstacleType_Pede"
    "strian\020\002\022\034\n\030ObstacleType_TrafficSign\020\003\022\035"
    "\n\031ObstacleType_TrafficLight\020\004\022\034\n\030Obstacl"
    "eType_ParkingSlot\020\005\022\031\n\025ObstacleType_Road"
    "Sign\020\006\022\030\n\024ObstacleType_Cyclist\020\022*\236\003\n\021Tra"
    "fficLightStyle\022\035\n\031TrafficLightStyle_Unkn"
    "own\020\000\022\033\n\027TrafficLightStyle_Other\020\001\022\032\n\026Tr"
    "afficLightStyle_Left\020\002\022\035\n\031TrafficLightSt"
    "yle_Forward\020\003\022\033\n\027TrafficLightStyle_Right"
    "\020\004\022\032\n\026TrafficLightStyle_Rect\020\005\022\027\n\023Traffi"
    "cLightStyle_X\020\006\022\037\n\033TrafficLightStyle_Non"
    "_Motor\020\007\022\034\n\030TrafficLightStyle_Return\020\010\022 "
    "\n\034TrafficLightStyle_Pedestrain\020\t\022\032\n\026Traf"
    "ficLightStyle_Time\020\n\022\034\n\030TrafficLightStyl"
    "e_Circle\020\013\022%\n!TrafficLightStyle_Left_And"
    "_Return\020\014*\247\001\n\022TrafficLightStatus\022\032\n\026Traf"
    "ficLightStatus_Off\020\000\022\032\n\026TrafficLightStat"
    "us_Red\020\001\022\034\n\030TrafficLightStatus_Green\020\002\022\035"
    "\n\031TrafficLightStatus_Yellow\020\003\022\034\n\030Traffic"
    "LightStatus_Other\020\004*\335)\n\017TrafficSignType\022"
    "\027\n\023TrSignType_I_Circle\020\000\022\030\n\024TrSignType_I"
    "_Forward\020\001\022\035\n\031TrSignType_I_Forward_Left\020"
    "\002\022$\n TrSignType_I_Forward_Left_Stereo\020\003\022"
    "\036\n\032TrSignType_I_Forward_Right\020\004\022%\n!TrSig"
    "nType_I_Forward_Right_Stereo\020\005\022\025\n\021TrSign"
    "Type_I_Honk\020\006\022\025\n\021TrSignType_I_Left\020\007\022\033\n\027"
    "TrSignType_I_Left_Right\020\010\022\032\n\026TrSignType_"
    "I_Left_Turn\020\t\022!\n\035TrSignType_I_Min_Speed_"
    "Lim100\020\n\022!\n\035TrSignType_I_Min_Speed_Lim11"
    "0\020\013\022 \n\034TrSignType_I_Min_Speed_Lim50\020\014\022 \n"
    "\034TrSignType_I_Min_Speed_Lim60\020\r\022 \n\034TrSig"
    "nType_I_Min_Speed_Lim70\020\016\022 \n\034TrSignType_"
    "I_Min_Speed_Lim80\020\017\022 \n\034TrSignType_I_Min_"
    "Speed_Lim90\020\020\022\027\n\023TrSignType_I_Motors\020\021\022\033"
    "\n\027TrSignType_I_Non_Motors\020\022\022!\n\035TrSignTyp"
    "e_I_Pedestrian_Cross\020\023\022\026\n\022TrSignType_I_R"
    "ight\020\024\022\033\n\027TrSignType_I_Right_Turn\020\025\022\025\n\021T"
    "rSignType_I_Walk\020\026\022\027\n\023TrSignType_P_Custo"
    "m\020\027\022\031\n\025TrSignType_P_Give_Way\020\030\022\033\n\027TrSign"
    "Type_P_Height_Lim\020\031\022\"\n\036TrSignType_P_No_A"
    "nimal_Vehicle\020\032\022\027\n\023TrSignType_P_No_Bus\020\033"
    "\022\027\n\023TrSignType_P_No_Car\020\034\022\"\n\036TrSignType_"
    "P_No_Cargo_Tricycle\020\035\022\035\n\031TrSignType_P_No"
    "_Dangerous\020\036\022\031\n\025TrSignType_P_No_Entry\020\037\022"
    " \n\034TrSignType_P_No_Forward_Left\020 \022!\n\035TrS"
    "ignType_P_No_Forward_Right\020!\022\032\n\026TrSignTy"
    "pe_P_No_Foward\020\"\022\033\n\027TrSignType_P_No_Horn"
    "ing\020#\022\031\n\025TrSignType_P_No_Human\020$\022(\n$TrSi"
    "gnType_P_No_Human_Cargo_Triangle\020%\022,\n(Tr"
    "SignType_P_No_Human_Passenger_Triangle\020&"
    "\022!\n\035TrSignType_P_No_Human_Vehicle\020\'\022#\n\037T"
    "rSignType_P_No_Left_Right_Turn\020(\022\035\n\031TrSi"
    "gnType_P_No_Left_Turn\020)\022 \n\034TrSignType_P_"
    "No_Long_Parking\020*\022!\n\035TrSignType_P_No_Mot"
    "o_Tricycle\020+\022\031\n\025TrSignType_P_No_Motor\020,\022"
    "\036\n\032TrSignType_P_No_Motorcycle\020-\022\035\n\031TrSig"
    "nType_P_No_Non_Motor\020.\022\033\n\027TrSignType_P_N"
    "o_Parking\020/\022\033\n\027TrSignType_P_No_Passing\0200"
    "\022\032\n\026TrSignType_P_No_Return\0201\022\036\n\032TrSignTy"
    "pe_P_No_Right_Turn\0202\022\033\n\027TrSignType_P_No_"
    "Tractor\0203\022\033\n\027TrSignType_P_No_Trailer\0204\022\031"
    "\n\025TrSignType_P_No_Truck\0205\022\026\n\022TrSignType_"
    "P_Noway\0206\022\036\n\032TrSignType_P_Parking_Check\020"
    "7\022\031\n\025TrSignType_P_Slow_For\0208\022\034\n\030TrSignTy"
    "pe_P_Speed_Lim10\0209\022\035\n\031TrSignType_P_Speed"
    "_Lim100\020:\022\035\n\031TrSignType_P_Speed_Lim105\020;"
    "\022\035\n\031TrSignType_P_Speed_Lim110\020<\022\035\n\031TrSig"
    "nType_P_Speed_Lim115\020=\022\035\n\031TrSignType_P_S"
    "peed_Lim120\020>\022\034\n\030TrSignType_P_Speed_Lim1"
    "5\020\?\022\034\n\030TrSignType_P_Speed_Lim20\020@\022\034\n\030TrS"
    "ignType_P_Speed_Lim25\020A\022\034\n\030TrSignType_P_"
    "Speed_Lim30\020B\022\034\n\030TrSignType_P_Speed_Lim3"
    "5\020C\022\034\n\030TrSignType_P_Speed_Lim40\020D\022\034\n\030TrS"
    "ignType_P_Speed_Lim45\020E\022\033\n\027TrSignType_P_"
    "Speed_Lim5\020F\022\034\n\030TrSignType_P_Speed_Lim50"
    "\020G\022\034\n\030TrSignType_P_Speed_Lim55\020H\022\034\n\030TrSi"
    "gnType_P_Speed_Lim60\020I\022\034\n\030TrSignType_P_S"
    "peed_Lim65\020J\022\034\n\030TrSignType_P_Speed_Lim70"
    "\020K\022\034\n\030TrSignType_P_Speed_Lim75\020L\022\034\n\030TrSi"
    "gnType_P_Speed_Lim80\020M\022\034\n\030TrSignType_P_S"
    "peed_Lim85\020N\022\034\n\030TrSignType_P_Speed_Lim90"
    "\020O\022\034\n\030TrSignType_P_Speed_Lim95\020P\022 \n\034TrSi"
    "gnType_P_Speed_Lim_Rev10\020Q\022!\n\035TrSignType"
    "_P_Speed_Lim_Rev100\020R\022!\n\035TrSignType_P_Sp"
    "eed_Lim_Rev105\020S\022!\n\035TrSignType_P_Speed_L"
    "im_Rev110\020T\022!\n\035TrSignType_P_Speed_Lim_Re"
    "v115\020U\022!\n\035TrSignType_P_Speed_Lim_Rev120\020"
    "V\022 \n\034TrSignType_P_Speed_Lim_Rev15\020W\022 \n\034T"
    "rSignType_P_Speed_Lim_Rev20\020X\022 \n\034TrSignT"
    "ype_P_Speed_Lim_Rev25\020Y\022 \n\034TrSignType_P_"
    "Speed_Lim_Rev30\020Z\022 \n\034TrSignType_P_Speed_"
    "Lim_Rev35\020[\022 \n\034TrSignType_P_Speed_Lim_Re"
    "v40\020\\\022 \n\034TrSignType_P_Speed_Lim_Rev45\020]\022"
    "\037\n\033TrSignType_P_Speed_Lim_Rev5\020^\022 \n\034TrSi"
    "gnType_P_Speed_Lim_Rev50\020_\022 \n\034TrSignType"
    "_P_Speed_Lim_Rev55\020`\022 \n\034TrSignType_P_Spe"
    "ed_Lim_Rev60\020a\022 \n\034TrSignType_P_Speed_Lim"
    "_Rev65\020b\022 \n\034TrSignType_P_Speed_Lim_Rev70"
    "\020c\022 \n\034TrSignType_P_Speed_Lim_Rev75\020d\022 \n\034"
    "TrSignType_P_Speed_Lim_Rev80\020e\022 \n\034TrSign"
    "Type_P_Speed_Lim_Rev85\020f\022 \n\034TrSignType_P"
    "_Speed_Lim_Rev90\020g\022 \n\034TrSignType_P_Speed"
    "_Lim_Rev95\020h\022\031\n\025TrSignType_P_Stop_For\020i\022"
    "\033\n\027TrSignType_P_Weight_Lim\020j\022!\n\035TrSignTy"
    "pe_P_Weight_Lim_wheel\020k\022\032\n\026TrSignType_P_"
    "Width_Lim\020l\022\037\n\033TrSignType_W_Accident_Pro"
    "ne\020m\022\027\n\023TrSignType_W_Animal\020n\022\034\n\030TrSignT"
    "ype_W_Bad_Weather\020o\022\025\n\021TrSignType_W_Bump"
    "\020p\022\026\n\022TrSignType_W_Bumpy\020q\022\031\n\025TrSignType"
    "_W_Children\020r\022\027\n\023TrSignType_W_Circle\020s\022 "
    "\n\034TrSignType_W_Continuous_Down\020t\022 \n\034TrSi"
    "gnType_W_Continuous_Turn\020u\022\026\n\022TrSignType"
    "_W_Cross\020v\022#\n\037TrSignType_W_Cross_Interse"
    "ction\020w\022\026\n\022TrSignType_W_Cycle\020x\022\031\n\025TrSig"
    "nType_W_Dam_Left\020y\022\032\n\026TrSignType_W_Dam_R"
    "ight\020z\022\027\n\023TrSignType_W_Danger\020{\022\036\n\032TrSig"
    "nType_W_Detour_Around\020|\022\034\n\030TrSignType_W_"
    "Detour_Left\020}\022\035\n\031TrSignType_W_Detour_Rig"
    "ht\020~\022\031\n\025TrSignType_W_Disabled\020\177\022\032\n\025TrSig"
    "nType_W_Domestic\020\200\001\022\026\n\021TrSignType_W_Down"
    "\020\201\001\022\027\n\022TrSignType_W_Ferry\020\202\001\022\025\n\020TrSignTy"
    "pe_W_Fog\020\203\001\022\026\n\021TrSignType_W_Ford\020\204\001\022!\n\034T"
    "rSignType_W_Guarded_Railway\020\205\001\022\035\n\030TrSign"
    "Type_W_Hump_Bridge\020\206\001\022\025\n\020TrSignType_W_Ic"
    "e\020\207\001\022\037\n\032TrSignType_W_Keep_Distance\020\210\001\022\033\n"
    "\026TrSignType_W_LR_Narrow\020\211\001\022\031\n\024TrSignType"
    "_W_LR_Turn\020\212\001\022\036\n\031TrSignType_W_Left_Falli"
    "ng\020\213\001\022\035\n\030TrSignType_W_Left_Narrow\020\214\001\022\033\n\026"
    "TrSignType_W_Left_Turn\020\215\001\022\033\n\026TrSignType_"
    "W_Low_Lying\020\216\001\022\034\n\027TrSignType_W_Merge_Lef"
    "t\020\217\001\022\035\n\030TrSignType_W_Merge_Right\020\220\001\022\034\n\027T"
    "rSignType_W_Mount_Left\020\221\001\022\035\n\030TrSignType_"
    "W_Mount_Right\020\222\001\022\037\n\032TrSignType_W_Narrow_"
    "Bridge\020\223\001\022\034\n\027TrSignType_W_Pedestrain\020\224\001\022"
    "\031\n\024TrSignType_W_RL_Turn\020\225\001\022\031\n\024TrSignType"
    "_W_Railway\020\226\001\022\026\n\021TrSignType_W_Rain\020\227\001\022\037\n"
    "\032TrSignType_W_Right_Falling\020\230\001\022\036\n\031TrSign"
    "Type_W_Right_Narrow\020\231\001\022\034\n\027TrSignType_W_R"
    "ight_Turn\020\232\001\022\033\n\026TrSignType_W_Side_Wind\020\233"
    "\001\022\026\n\021TrSignType_W_Slip\020\234\001\022\026\n\021TrSignType_"
    "W_Slow\020\235\001\022 \n\033TrSignType_W_T_Intersection"
    "\020\236\001\022\030\n\023TrSignType_W_T_Shap\020\237\001\022\035\n\030TrSignT"
    "ype_W_T_Shap_Left\020\240\001\022\036\n\031TrSignType_W_T_S"
    "hap_Right\020\241\001\022\031\n\024TrSignType_W_T_Shaps\020\242\001\022"
    "\027\n\022TrSignType_W_Tidal\020\243\001\022\037\n\032TrSignType_W"
    "_Traffic_Light\020\244\001\022\030\n\023TrSignType_W_Tunnel"
    "\020\245\001\022\"\n\035TrSignType_W_Tunnel_Headlight\020\246\001\022"
    "\031\n\024TrSignType_W_Two_Way\020\247\001\022\024\n\017TrSignType"
    "_W_Up\020\250\001\022\037\n\032TrSignType_W_Vehicle_Queue\020\251"
    "\001\022\031\n\024TrSignType_W_Village\020\252\001\022\031\n\024TrSignTy"
    "pe_W_Working\020\253\001\022\031\n\024TrSignType_W_YB_Left\020"
    "\254\001\022\032\n\025TrSignType_W_YB_Right\020\255\001\022\030\n\023TrSign"
    "Type_W_Y_Left\020\256\001\022\031\n\024TrSignType_W_Y_Right"
    "\020\257\001*O\n\021ParkingSlotStatus\022\036\n\032ParkingSlotS"
    "tatus_Occupied\020\000\022\032\n\026ParkingSlotStatus_Fr"
    "ee\020\001*\272\001\n\013VehProperty\022\024\n\020VehProperty_Type"
    "\020\000\022\036\n\032VehProperty_Classification\020\001\022\025\n\021Ve"
    "hProperty_Light\020\002\022\025\n\021VehProperty_3DBox\020\003"
    "\022\031\n\025VehProperty_KeyPoints\020\004\022\027\n\023VehProper"
    "ty_VehBBox\020\005\022\023\n\017VehProperty_Cnt\020\006*z\n\031Veh"
    "PropertyPerceptionType\022#\n\037Veh_Perception"
    "Type_LicensePlate\020\000\022\034\n\030Veh_PerceptionTyp"
    "e_Wheel\020\001\022\032\n\026Veh_PerceptionType_Cnt\020\002*A\n"
    "\024TrafficLightProperty\022\023\n\017TlProperty_Type"
    "\020\000\022\024\n\020TlProperty_Color\020\001**\n\023TrafficSignP"
    "roperty\022\023\n\017TsProperty_Type\020\000*\'\n\020RoadSign"
    "Property\022\023\n\017RsProperty_Type\020\000*\273\002\n\024Obstac"
    "leRawModelType\022\030\n\024ObstacleRawModel_Car\020\000"
    "\022\034\n\030ObstacleRawModel_FullCar\020\001\022\030\n\024Obstac"
    "leRawModel_Ped\020\002\022\031\n\025ObstacleRawModel_Hea"
    "d\020\003\022\031\n\025ObstacleRawModel_Rare\020\004\022 \n\034Obstac"
    "leRawModel_TrafficSign\020\005\022!\n\035ObstacleRawM"
    "odel_TrafficLight\020\006\022\031\n\025ObstacleRawModel_"
    "Lane\020\007\022\035\n\031ObstacleRawModel_RoadSign\020\n\022\034\n"
    "\030ObstacleRawModel_Cyclist\020\020*Y\n\014LanePosit"
    "ion\022\030\n\024LANE_POSITION_CENTER\020\000\022\026\n\022LANE_PO"
    "SITION_LEFT\020\001\022\027\n\023LANE_POSITION_RIGHT\020\002*3"
    "\n\022FreeSpacePointType\022\035\n\030ParsingLabelType"
    "_Invalid\020\377\001*<\n\nCameraType\022\026\n\022CameraType_"
    "PinHole\020\000\022\026\n\022CameraType_FishEye\020\001*<\n\rCam"
    "eraVersion\022\024\n\020CameraVersion_CV\020\000\022\025\n\021Came"
    "raVersion_VCS\020\001*|\n\021CalibrationStatus\022\035\n\031"
    "CalibrationStatus_Default\020\000\022#\n\037Calibrati"
    "onStatus_IntrinsicDone\020\001\022#\n\037CalibrationS"
    "tatus_ExtrinsicDone\020\002*:\n\010DataType\022\014\n\010DAT"
    "A_IMG\020\000\022\020\n\014DATA_PARSING\020\001\022\016\n\nDATA_RADAR\020"
    "\002*\244\013\n\020PasringLableType\022\034\n\030PasringLableTy"
    "peRsh_Road\020\000\022 \n\034PasringLableTypeRsh_Side"
    "walk\020\001\022 \n\034PasringLableTypeRsh_Building\020\002"
    "\022#\n\037PasringLableTypeRsh_LaneMarking\020\003\022\035\n"
    "\031PasringLableTypeRsh_Fence\020\004\022\034\n\030PasringL"
    "ableTypeRsh_Pole\020\005\022$\n PasringLableTypeRs"
    "h_TrafficLight\020\006\022#\n\037PasringLableTypeRsh_"
    "TrafficSign\020\007\022\"\n\036PasringLableTypeRsh_Veg"
    "etation\020\010\022\037\n\033PasringLableTypeRsh_Terrain"
    "\020\t\022\033\n\027PasringLableTypeRsh_Sky\020\n\022\036\n\032Pasri"
    "ngLableTypeRsh_Person\020\013\022\035\n\031PasringLableT"
    "ypeRsh_Rider\020\014\022\033\n\027PasringLableTypeRsh_Ca"
    "r\020\r\022\035\n\031PasringLableTypeRsh_Truck\020\016\022\033\n\027Pa"
    "sringLableTypeRsh_Bus\020\017\022\035\n\031PasringLableT"
    "ypeRsh_Train\020\020\022\"\n\036PasringLableTypeRsh_Mo"
    "torcycle\020\021\022\037\n\033PasringLableTypeRsh_Bicycl"
    "e\020\022\022!\n\035PasringLableTypeRsh_GuidePost\020\023\022%"
    "\n!PasringLableTypeRsh_CrosswalkLine\020\024\022$\n"
    " PasringLableTypeRsh_TrafficArrow\020\025\022 \n\034P"
    "asringLableTypeRsh_SignLine\020\026\022!\n\035Pasring"
    "LableTypeRsh_GuideLine\020\027\022#\n\037PasringLable"
    "TypeRsh_TrafficCone\020\030\022\036\n\032PasringLableTyp"
    "eRsh_Barrel\020\031\022 \n\034PasringLableTypeRsh_Sto"
    "pLine\020\032\022!\n\035PasringLableTypeRsh_SpeedMark"
    "\020\033\022\037\n\033PasringLableTypeRsh_Diamond\020\034\022#\n\037P"
    "asringLableTypeRsh_BicycleSign\020\035\022\"\n\036Pasr"
    "ingLableTypeRsh_SpeedBumps\020\036\022 \n\034PasringL"
    "ableTypeRsh_Tricycle\020\037\022(\n$PasringLableTy"
    "peRsh_SlowDownTriangle\020 \022\034\n\030PasringLable"
    "TypeRsh_Mask\020!\022\037\n\033PasringLableTypeRsh_Po"
    "tHole\020\"\022\035\n\031PasringLableTypeRsh_Other\020#\022\034"
    "\n\030PasringLableTypeRsh_Curb\020$\022#\n\037PasringL"
    "ableTypeRsh_ParkingLine\020%\022$\n PasringLabl"
    "eTypeRsh_ParkingSpace\020&\022\"\n\036PasringLableT"
    "ypeRsh_ParkingRod\020\'\022#\n\037PasringLableTypeR"
    "sh_ParkingLock\020(\022\036\n\032PasringLableTypeRsh_"
    "Column\020)", 14608);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "common.proto", &protobuf_RegisterTypes);
  Point::default_instance_ = new Point();
  PointI::default_instance_ = new PointI();
  Contour::default_instance_ = new Contour();
  Polygon::default_instance_ = new Polygon();
  Rect::default_instance_ = new Rect();
  OBBox2D::default_instance_ = new OBBox2D();
  Box3D::default_instance_ = new Box3D();
  SkeletonPoint::default_instance_ = new SkeletonPoint();
  Image::default_instance_ = new Image();
  Velocity::default_instance_ = new Velocity();
  Line::default_instance_ = new Line();
  Lines::default_instance_ = new Lines();
  WorldSpaceInfo::default_instance_ = new WorldSpaceInfo();
  ImageSpaceInfo::default_instance_ = new ImageSpaceInfo();
  Obstacle::default_instance_ = new Obstacle();
  Obstacles::default_instance_ = new Obstacles();
  FeatureMap::default_instance_ = new FeatureMap();
  ObstacleRaw::default_instance_ = new ObstacleRaw();
  ObstacleRaws::default_instance_ = new ObstacleRaws();
  FreeSpacePoints::default_instance_ = new FreeSpacePoints();
  Box3DRaw::default_instance_ = new Box3DRaw();
  Box3DRaws::default_instance_ = new Box3DRaws();
  Skeleton::default_instance_ = new Skeleton();
  SkeletonRaw::default_instance_ = new SkeletonRaw();
  SkeletonRaws::default_instance_ = new SkeletonRaws();
  CameraMatrix::default_instance_ = new CameraMatrix();
  DistortParam::default_instance_ = new DistortParam();
  VCSParam::default_instance_ = new VCSParam();
  CameraParam::default_instance_ = new CameraParam();
  MotionFrame::default_instance_ = new MotionFrame();
  OdometryFrame::default_instance_ = new OdometryFrame();
  SerializedData::default_instance_ = new SerializedData();
  DataDescriptor::default_instance_ = new DataDescriptor();
  Color::default_instance_ = new Color();
  ParsingSetting::default_instance_ = new ParsingSetting();
  Point::default_instance_->InitAsDefaultInstance();
  PointI::default_instance_->InitAsDefaultInstance();
  Contour::default_instance_->InitAsDefaultInstance();
  Polygon::default_instance_->InitAsDefaultInstance();
  Rect::default_instance_->InitAsDefaultInstance();
  OBBox2D::default_instance_->InitAsDefaultInstance();
  Box3D::default_instance_->InitAsDefaultInstance();
  SkeletonPoint::default_instance_->InitAsDefaultInstance();
  Image::default_instance_->InitAsDefaultInstance();
  Velocity::default_instance_->InitAsDefaultInstance();
  Line::default_instance_->InitAsDefaultInstance();
  Lines::default_instance_->InitAsDefaultInstance();
  WorldSpaceInfo::default_instance_->InitAsDefaultInstance();
  ImageSpaceInfo::default_instance_->InitAsDefaultInstance();
  Obstacle::default_instance_->InitAsDefaultInstance();
  Obstacles::default_instance_->InitAsDefaultInstance();
  FeatureMap::default_instance_->InitAsDefaultInstance();
  ObstacleRaw::default_instance_->InitAsDefaultInstance();
  ObstacleRaws::default_instance_->InitAsDefaultInstance();
  FreeSpacePoints::default_instance_->InitAsDefaultInstance();
  Box3DRaw::default_instance_->InitAsDefaultInstance();
  Box3DRaws::default_instance_->InitAsDefaultInstance();
  Skeleton::default_instance_->InitAsDefaultInstance();
  SkeletonRaw::default_instance_->InitAsDefaultInstance();
  SkeletonRaws::default_instance_->InitAsDefaultInstance();
  CameraMatrix::default_instance_->InitAsDefaultInstance();
  DistortParam::default_instance_->InitAsDefaultInstance();
  VCSParam::default_instance_->InitAsDefaultInstance();
  CameraParam::default_instance_->InitAsDefaultInstance();
  MotionFrame::default_instance_->InitAsDefaultInstance();
  OdometryFrame::default_instance_->InitAsDefaultInstance();
  SerializedData::default_instance_->InitAsDefaultInstance();
  DataDescriptor::default_instance_->InitAsDefaultInstance();
  Color::default_instance_->InitAsDefaultInstance();
  ParsingSetting::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_common_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_common_2eproto {
  StaticDescriptorInitializer_common_2eproto() {
    protobuf_AddDesc_common_2eproto();
  }
} static_descriptor_initializer_common_2eproto_;
const ::google::protobuf::EnumDescriptor* SkeletonType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SkeletonType_descriptor_;
}
bool SkeletonType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImageFormat_descriptor_;
}
bool ImageFormat_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ParsingFormat_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ParsingFormat_descriptor_;
}
bool ParsingFormat_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LineType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LineType_descriptor_;
}
bool LineType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ObstacleType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ObstacleType_descriptor_;
}
bool ObstacleType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 18:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TrafficLightStyle_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficLightStyle_descriptor_;
}
bool TrafficLightStyle_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TrafficLightStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficLightStatus_descriptor_;
}
bool TrafficLightStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TrafficSignType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSignType_descriptor_;
}
bool TrafficSignType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ParkingSlotStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ParkingSlotStatus_descriptor_;
}
bool ParkingSlotStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* VehProperty_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VehProperty_descriptor_;
}
bool VehProperty_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* VehPropertyPerceptionType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VehPropertyPerceptionType_descriptor_;
}
bool VehPropertyPerceptionType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TrafficLightProperty_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficLightProperty_descriptor_;
}
bool TrafficLightProperty_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TrafficSignProperty_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSignProperty_descriptor_;
}
bool TrafficSignProperty_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadSignProperty_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoadSignProperty_descriptor_;
}
bool RoadSignProperty_IsValid(int value) {
  switch(value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ObstacleRawModelType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ObstacleRawModelType_descriptor_;
}
bool ObstacleRawModelType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 10:
    case 16:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LanePosition_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LanePosition_descriptor_;
}
bool LanePosition_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* FreeSpacePointType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FreeSpacePointType_descriptor_;
}
bool FreeSpacePointType_IsValid(int value) {
  switch(value) {
    case 255:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CameraType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CameraType_descriptor_;
}
bool CameraType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CameraVersion_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CameraVersion_descriptor_;
}
bool CameraVersion_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CalibrationStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CalibrationStatus_descriptor_;
}
bool CalibrationStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* DataType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataType_descriptor_;
}
bool DataType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PasringLableType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PasringLableType_descriptor_;
}
bool PasringLableType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Point::kXFieldNumber;
const int Point::kYFieldNumber;
const int Point::kZFieldNumber;
#endif  // !_MSC_VER

Point::Point()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Point)
}

void Point::InitAsDefaultInstance() {
}

Point::Point(const Point& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Point)
}

void Point::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:CommonProto.Point)
  SharedDtor();
}

void Point::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Point_descriptor_;
}

const Point& Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Point* Point::default_instance_ = NULL;

Point* Point::New() const {
  return new Point;
}

void Point::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Point*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, z_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Point)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // optional float z = 3;
      case 3: {
        if (tag == 29) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Point)
  return false;
#undef DO_
}

void Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Point)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // optional float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Point)
}

::google::protobuf::uint8* Point::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Point)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // optional float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Point)
  return target;
}

int Point::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // optional float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Point::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Point* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Point*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Point::MergeFrom(const Point& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Point::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Point::CopyFrom(const Point& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Point::Swap(Point* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Point_descriptor_;
  metadata.reflection = Point_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PointI::kXFieldNumber;
const int PointI::kYFieldNumber;
const int PointI::kZFieldNumber;
#endif  // !_MSC_VER

PointI::PointI()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.PointI)
}

void PointI::InitAsDefaultInstance() {
}

PointI::PointI(const PointI& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.PointI)
}

void PointI::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PointI::~PointI() {
  // @@protoc_insertion_point(destructor:CommonProto.PointI)
  SharedDtor();
}

void PointI::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PointI::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PointI::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PointI_descriptor_;
}

const PointI& PointI::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

PointI* PointI::default_instance_ = NULL;

PointI* PointI::New() const {
  return new PointI;
}

void PointI::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PointI*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, z_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PointI::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.PointI)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // required int32 y = 2;
      case 2: {
        if (tag == 16) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_z;
        break;
      }

      // optional int32 z = 3;
      case 3: {
        if (tag == 24) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.PointI)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.PointI)
  return false;
#undef DO_
}

void PointI::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.PointI)
  // required int32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // required int32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // optional int32 z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.PointI)
}

::google::protobuf::uint8* PointI::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.PointI)
  // required int32 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // required int32 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  // optional int32 z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.PointI)
  return target;
}

int PointI::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // required int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // optional int32 z = 3;
    if (has_z()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->z());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PointI::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PointI* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PointI*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PointI::MergeFrom(const PointI& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PointI::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointI::CopyFrom(const PointI& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointI::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PointI::Swap(PointI* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PointI::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PointI_descriptor_;
  metadata.reflection = PointI_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Contour::kPtsFieldNumber;
#endif  // !_MSC_VER

Contour::Contour()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Contour)
}

void Contour::InitAsDefaultInstance() {
}

Contour::Contour(const Contour& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Contour)
}

void Contour::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Contour::~Contour() {
  // @@protoc_insertion_point(destructor:CommonProto.Contour)
  SharedDtor();
}

void Contour::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Contour::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Contour::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Contour_descriptor_;
}

const Contour& Contour::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Contour* Contour::default_instance_ = NULL;

Contour* Contour::New() const {
  return new Contour;
}

void Contour::Clear() {
  pts_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Contour::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Contour)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CommonProto.Point pts = 1;
      case 1: {
        if (tag == 10) {
         parse_pts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pts()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_pts;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Contour)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Contour)
  return false;
#undef DO_
}

void Contour::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Contour)
  // repeated .CommonProto.Point pts = 1;
  for (int i = 0; i < this->pts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pts(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Contour)
}

::google::protobuf::uint8* Contour::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Contour)
  // repeated .CommonProto.Point pts = 1;
  for (int i = 0; i < this->pts_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pts(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Contour)
  return target;
}

int Contour::ByteSize() const {
  int total_size = 0;

  // repeated .CommonProto.Point pts = 1;
  total_size += 1 * this->pts_size();
  for (int i = 0; i < this->pts_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pts(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Contour::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Contour* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Contour*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Contour::MergeFrom(const Contour& from) {
  GOOGLE_CHECK_NE(&from, this);
  pts_.MergeFrom(from.pts_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Contour::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Contour::CopyFrom(const Contour& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Contour::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->pts())) return false;
  return true;
}

void Contour::Swap(Contour* other) {
  if (other != this) {
    pts_.Swap(&other->pts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Contour::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Contour_descriptor_;
  metadata.reflection = Contour_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Polygon::kPtsFieldNumber;
#endif  // !_MSC_VER

Polygon::Polygon()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Polygon)
}

void Polygon::InitAsDefaultInstance() {
}

Polygon::Polygon(const Polygon& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Polygon)
}

void Polygon::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Polygon::~Polygon() {
  // @@protoc_insertion_point(destructor:CommonProto.Polygon)
  SharedDtor();
}

void Polygon::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Polygon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Polygon::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Polygon_descriptor_;
}

const Polygon& Polygon::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Polygon* Polygon::default_instance_ = NULL;

Polygon* Polygon::New() const {
  return new Polygon;
}

void Polygon::Clear() {
  pts_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Polygon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Polygon)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CommonProto.Point pts = 1;
      case 1: {
        if (tag == 10) {
         parse_pts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pts()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_pts;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Polygon)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Polygon)
  return false;
#undef DO_
}

void Polygon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Polygon)
  // repeated .CommonProto.Point pts = 1;
  for (int i = 0; i < this->pts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pts(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Polygon)
}

::google::protobuf::uint8* Polygon::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Polygon)
  // repeated .CommonProto.Point pts = 1;
  for (int i = 0; i < this->pts_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pts(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Polygon)
  return target;
}

int Polygon::ByteSize() const {
  int total_size = 0;

  // repeated .CommonProto.Point pts = 1;
  total_size += 1 * this->pts_size();
  for (int i = 0; i < this->pts_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pts(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Polygon::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Polygon* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Polygon*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Polygon::MergeFrom(const Polygon& from) {
  GOOGLE_CHECK_NE(&from, this);
  pts_.MergeFrom(from.pts_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Polygon::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Polygon::CopyFrom(const Polygon& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polygon::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->pts())) return false;
  return true;
}

void Polygon::Swap(Polygon* other) {
  if (other != this) {
    pts_.Swap(&other->pts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Polygon::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Polygon_descriptor_;
  metadata.reflection = Polygon_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Rect::kLeftFieldNumber;
const int Rect::kTopFieldNumber;
const int Rect::kRightFieldNumber;
const int Rect::kBottomFieldNumber;
#endif  // !_MSC_VER

Rect::Rect()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Rect)
}

void Rect::InitAsDefaultInstance() {
}

Rect::Rect(const Rect& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Rect)
}

void Rect::SharedCtor() {
  _cached_size_ = 0;
  left_ = 0;
  top_ = 0;
  right_ = 0;
  bottom_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Rect::~Rect() {
  // @@protoc_insertion_point(destructor:CommonProto.Rect)
  SharedDtor();
}

void Rect::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Rect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Rect::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Rect_descriptor_;
}

const Rect& Rect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Rect* Rect::default_instance_ = NULL;

Rect* Rect::New() const {
  return new Rect;
}

void Rect::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Rect*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(left_, bottom_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Rect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Rect)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float left = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &left_)));
          set_has_left();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_top;
        break;
      }

      // required float top = 2;
      case 2: {
        if (tag == 21) {
         parse_top:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &top_)));
          set_has_top();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_right;
        break;
      }

      // required float right = 3;
      case 3: {
        if (tag == 29) {
         parse_right:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &right_)));
          set_has_right();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_bottom;
        break;
      }

      // required float bottom = 4;
      case 4: {
        if (tag == 37) {
         parse_bottom:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bottom_)));
          set_has_bottom();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Rect)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Rect)
  return false;
#undef DO_
}

void Rect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Rect)
  // required float left = 1;
  if (has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->left(), output);
  }

  // required float top = 2;
  if (has_top()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->top(), output);
  }

  // required float right = 3;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->right(), output);
  }

  // required float bottom = 4;
  if (has_bottom()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->bottom(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Rect)
}

::google::protobuf::uint8* Rect::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Rect)
  // required float left = 1;
  if (has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->left(), target);
  }

  // required float top = 2;
  if (has_top()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->top(), target);
  }

  // required float right = 3;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->right(), target);
  }

  // required float bottom = 4;
  if (has_bottom()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->bottom(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Rect)
  return target;
}

int Rect::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float left = 1;
    if (has_left()) {
      total_size += 1 + 4;
    }

    // required float top = 2;
    if (has_top()) {
      total_size += 1 + 4;
    }

    // required float right = 3;
    if (has_right()) {
      total_size += 1 + 4;
    }

    // required float bottom = 4;
    if (has_bottom()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Rect::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Rect* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Rect*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Rect::MergeFrom(const Rect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_left()) {
      set_left(from.left());
    }
    if (from.has_top()) {
      set_top(from.top());
    }
    if (from.has_right()) {
      set_right(from.right());
    }
    if (from.has_bottom()) {
      set_bottom(from.bottom());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Rect::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Rect::CopyFrom(const Rect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rect::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Rect::Swap(Rect* other) {
  if (other != this) {
    std::swap(left_, other->left_);
    std::swap(top_, other->top_);
    std::swap(right_, other->right_);
    std::swap(bottom_, other->bottom_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Rect::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Rect_descriptor_;
  metadata.reflection = Rect_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OBBox2D::kCornerFieldNumber;
const int OBBox2D::kAxesPtsFieldNumber;
const int OBBox2D::kSizeFieldNumber;
#endif  // !_MSC_VER

OBBox2D::OBBox2D()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.OBBox2D)
}

void OBBox2D::InitAsDefaultInstance() {
  corner_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
}

OBBox2D::OBBox2D(const OBBox2D& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.OBBox2D)
}

void OBBox2D::SharedCtor() {
  _cached_size_ = 0;
  corner_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OBBox2D::~OBBox2D() {
  // @@protoc_insertion_point(destructor:CommonProto.OBBox2D)
  SharedDtor();
}

void OBBox2D::SharedDtor() {
  if (this != default_instance_) {
    delete corner_;
  }
}

void OBBox2D::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OBBox2D::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OBBox2D_descriptor_;
}

const OBBox2D& OBBox2D::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

OBBox2D* OBBox2D::default_instance_ = NULL;

OBBox2D* OBBox2D::New() const {
  return new OBBox2D;
}

void OBBox2D::Clear() {
  if (has_corner()) {
    if (corner_ != NULL) corner_->::CommonProto::Point::Clear();
  }
  axes_pts_.Clear();
  size_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OBBox2D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.OBBox2D)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .CommonProto.Point corner = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_corner()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_axes_pts;
        break;
      }

      // repeated .CommonProto.Point axes_pts = 2;
      case 2: {
        if (tag == 18) {
         parse_axes_pts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_axes_pts()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_axes_pts;
        if (input->ExpectTag(29)) goto parse_size;
        break;
      }

      // repeated float size = 3;
      case 3: {
        if (tag == 29) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_size())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_size())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_size;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.OBBox2D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.OBBox2D)
  return false;
#undef DO_
}

void OBBox2D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.OBBox2D)
  // required .CommonProto.Point corner = 1;
  if (has_corner()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->corner(), output);
  }

  // repeated .CommonProto.Point axes_pts = 2;
  for (int i = 0; i < this->axes_pts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->axes_pts(i), output);
  }

  // repeated float size = 3;
  for (int i = 0; i < this->size_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->size(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.OBBox2D)
}

::google::protobuf::uint8* OBBox2D::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.OBBox2D)
  // required .CommonProto.Point corner = 1;
  if (has_corner()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->corner(), target);
  }

  // repeated .CommonProto.Point axes_pts = 2;
  for (int i = 0; i < this->axes_pts_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->axes_pts(i), target);
  }

  // repeated float size = 3;
  for (int i = 0; i < this->size_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(3, this->size(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.OBBox2D)
  return target;
}

int OBBox2D::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .CommonProto.Point corner = 1;
    if (has_corner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->corner());
    }

  }
  // repeated .CommonProto.Point axes_pts = 2;
  total_size += 1 * this->axes_pts_size();
  for (int i = 0; i < this->axes_pts_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->axes_pts(i));
  }

  // repeated float size = 3;
  {
    int data_size = 0;
    data_size = 4 * this->size_size();
    total_size += 1 * this->size_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OBBox2D::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OBBox2D* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OBBox2D*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OBBox2D::MergeFrom(const OBBox2D& from) {
  GOOGLE_CHECK_NE(&from, this);
  axes_pts_.MergeFrom(from.axes_pts_);
  size_.MergeFrom(from.size_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_corner()) {
      mutable_corner()->::CommonProto::Point::MergeFrom(from.corner());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OBBox2D::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OBBox2D::CopyFrom(const OBBox2D& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OBBox2D::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_corner()) {
    if (!this->corner().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->axes_pts())) return false;
  return true;
}

void OBBox2D::Swap(OBBox2D* other) {
  if (other != this) {
    std::swap(corner_, other->corner_);
    axes_pts_.Swap(&other->axes_pts_);
    size_.Swap(&other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OBBox2D::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OBBox2D_descriptor_;
  metadata.reflection = OBBox2D_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Box3D::kLowerLtFieldNumber;
const int Box3D::kLowerLbFieldNumber;
const int Box3D::kLowerRbFieldNumber;
const int Box3D::kLowerRtFieldNumber;
const int Box3D::kUpperLtFieldNumber;
const int Box3D::kUpperLbFieldNumber;
const int Box3D::kUpperRbFieldNumber;
const int Box3D::kUpperRtFieldNumber;
const int Box3D::kConfFieldNumber;
#endif  // !_MSC_VER

Box3D::Box3D()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Box3D)
}

void Box3D::InitAsDefaultInstance() {
  lower_lt_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
  lower_lb_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
  lower_rb_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
  lower_rt_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
  upper_lt_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
  upper_lb_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
  upper_rb_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
  upper_rt_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
}

Box3D::Box3D(const Box3D& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Box3D)
}

void Box3D::SharedCtor() {
  _cached_size_ = 0;
  lower_lt_ = NULL;
  lower_lb_ = NULL;
  lower_rb_ = NULL;
  lower_rt_ = NULL;
  upper_lt_ = NULL;
  upper_lb_ = NULL;
  upper_rb_ = NULL;
  upper_rt_ = NULL;
  conf_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Box3D::~Box3D() {
  // @@protoc_insertion_point(destructor:CommonProto.Box3D)
  SharedDtor();
}

void Box3D::SharedDtor() {
  if (this != default_instance_) {
    delete lower_lt_;
    delete lower_lb_;
    delete lower_rb_;
    delete lower_rt_;
    delete upper_lt_;
    delete upper_lb_;
    delete upper_rb_;
    delete upper_rt_;
  }
}

void Box3D::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Box3D::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Box3D_descriptor_;
}

const Box3D& Box3D::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Box3D* Box3D::default_instance_ = NULL;

Box3D* Box3D::New() const {
  return new Box3D;
}

void Box3D::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_lower_lt()) {
      if (lower_lt_ != NULL) lower_lt_->::CommonProto::Point::Clear();
    }
    if (has_lower_lb()) {
      if (lower_lb_ != NULL) lower_lb_->::CommonProto::Point::Clear();
    }
    if (has_lower_rb()) {
      if (lower_rb_ != NULL) lower_rb_->::CommonProto::Point::Clear();
    }
    if (has_lower_rt()) {
      if (lower_rt_ != NULL) lower_rt_->::CommonProto::Point::Clear();
    }
    if (has_upper_lt()) {
      if (upper_lt_ != NULL) upper_lt_->::CommonProto::Point::Clear();
    }
    if (has_upper_lb()) {
      if (upper_lb_ != NULL) upper_lb_->::CommonProto::Point::Clear();
    }
    if (has_upper_rb()) {
      if (upper_rb_ != NULL) upper_rb_->::CommonProto::Point::Clear();
    }
    if (has_upper_rt()) {
      if (upper_rt_ != NULL) upper_rt_->::CommonProto::Point::Clear();
    }
  }
  conf_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Box3D::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Box3D)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .CommonProto.Point lower_lt = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lower_lt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_lower_lb;
        break;
      }

      // required .CommonProto.Point lower_lb = 2;
      case 2: {
        if (tag == 18) {
         parse_lower_lb:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lower_lb()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_lower_rb;
        break;
      }

      // required .CommonProto.Point lower_rb = 3;
      case 3: {
        if (tag == 26) {
         parse_lower_rb:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lower_rb()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_lower_rt;
        break;
      }

      // required .CommonProto.Point lower_rt = 4;
      case 4: {
        if (tag == 34) {
         parse_lower_rt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lower_rt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_upper_lt;
        break;
      }

      // required .CommonProto.Point upper_lt = 5;
      case 5: {
        if (tag == 42) {
         parse_upper_lt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_upper_lt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_upper_lb;
        break;
      }

      // required .CommonProto.Point upper_lb = 6;
      case 6: {
        if (tag == 50) {
         parse_upper_lb:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_upper_lb()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_upper_rb;
        break;
      }

      // required .CommonProto.Point upper_rb = 7;
      case 7: {
        if (tag == 58) {
         parse_upper_rb:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_upper_rb()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_upper_rt;
        break;
      }

      // required .CommonProto.Point upper_rt = 8;
      case 8: {
        if (tag == 66) {
         parse_upper_rt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_upper_rt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_conf;
        break;
      }

      // optional float conf = 9;
      case 9: {
        if (tag == 77) {
         parse_conf:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_)));
          set_has_conf();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Box3D)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Box3D)
  return false;
#undef DO_
}

void Box3D::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Box3D)
  // required .CommonProto.Point lower_lt = 1;
  if (has_lower_lt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->lower_lt(), output);
  }

  // required .CommonProto.Point lower_lb = 2;
  if (has_lower_lb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->lower_lb(), output);
  }

  // required .CommonProto.Point lower_rb = 3;
  if (has_lower_rb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->lower_rb(), output);
  }

  // required .CommonProto.Point lower_rt = 4;
  if (has_lower_rt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->lower_rt(), output);
  }

  // required .CommonProto.Point upper_lt = 5;
  if (has_upper_lt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->upper_lt(), output);
  }

  // required .CommonProto.Point upper_lb = 6;
  if (has_upper_lb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->upper_lb(), output);
  }

  // required .CommonProto.Point upper_rb = 7;
  if (has_upper_rb()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->upper_rb(), output);
  }

  // required .CommonProto.Point upper_rt = 8;
  if (has_upper_rt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->upper_rt(), output);
  }

  // optional float conf = 9;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->conf(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Box3D)
}

::google::protobuf::uint8* Box3D::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Box3D)
  // required .CommonProto.Point lower_lt = 1;
  if (has_lower_lt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->lower_lt(), target);
  }

  // required .CommonProto.Point lower_lb = 2;
  if (has_lower_lb()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->lower_lb(), target);
  }

  // required .CommonProto.Point lower_rb = 3;
  if (has_lower_rb()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->lower_rb(), target);
  }

  // required .CommonProto.Point lower_rt = 4;
  if (has_lower_rt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->lower_rt(), target);
  }

  // required .CommonProto.Point upper_lt = 5;
  if (has_upper_lt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->upper_lt(), target);
  }

  // required .CommonProto.Point upper_lb = 6;
  if (has_upper_lb()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->upper_lb(), target);
  }

  // required .CommonProto.Point upper_rb = 7;
  if (has_upper_rb()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->upper_rb(), target);
  }

  // required .CommonProto.Point upper_rt = 8;
  if (has_upper_rt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->upper_rt(), target);
  }

  // optional float conf = 9;
  if (has_conf()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->conf(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Box3D)
  return target;
}

int Box3D::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .CommonProto.Point lower_lt = 1;
    if (has_lower_lt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lower_lt());
    }

    // required .CommonProto.Point lower_lb = 2;
    if (has_lower_lb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lower_lb());
    }

    // required .CommonProto.Point lower_rb = 3;
    if (has_lower_rb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lower_rb());
    }

    // required .CommonProto.Point lower_rt = 4;
    if (has_lower_rt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lower_rt());
    }

    // required .CommonProto.Point upper_lt = 5;
    if (has_upper_lt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->upper_lt());
    }

    // required .CommonProto.Point upper_lb = 6;
    if (has_upper_lb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->upper_lb());
    }

    // required .CommonProto.Point upper_rb = 7;
    if (has_upper_rb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->upper_rb());
    }

    // required .CommonProto.Point upper_rt = 8;
    if (has_upper_rt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->upper_rt());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float conf = 9;
    if (has_conf()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Box3D::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Box3D* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Box3D*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Box3D::MergeFrom(const Box3D& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lower_lt()) {
      mutable_lower_lt()->::CommonProto::Point::MergeFrom(from.lower_lt());
    }
    if (from.has_lower_lb()) {
      mutable_lower_lb()->::CommonProto::Point::MergeFrom(from.lower_lb());
    }
    if (from.has_lower_rb()) {
      mutable_lower_rb()->::CommonProto::Point::MergeFrom(from.lower_rb());
    }
    if (from.has_lower_rt()) {
      mutable_lower_rt()->::CommonProto::Point::MergeFrom(from.lower_rt());
    }
    if (from.has_upper_lt()) {
      mutable_upper_lt()->::CommonProto::Point::MergeFrom(from.upper_lt());
    }
    if (from.has_upper_lb()) {
      mutable_upper_lb()->::CommonProto::Point::MergeFrom(from.upper_lb());
    }
    if (from.has_upper_rb()) {
      mutable_upper_rb()->::CommonProto::Point::MergeFrom(from.upper_rb());
    }
    if (from.has_upper_rt()) {
      mutable_upper_rt()->::CommonProto::Point::MergeFrom(from.upper_rt());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_conf()) {
      set_conf(from.conf());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Box3D::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Box3D::CopyFrom(const Box3D& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Box3D::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_lower_lt()) {
    if (!this->lower_lt().IsInitialized()) return false;
  }
  if (has_lower_lb()) {
    if (!this->lower_lb().IsInitialized()) return false;
  }
  if (has_lower_rb()) {
    if (!this->lower_rb().IsInitialized()) return false;
  }
  if (has_lower_rt()) {
    if (!this->lower_rt().IsInitialized()) return false;
  }
  if (has_upper_lt()) {
    if (!this->upper_lt().IsInitialized()) return false;
  }
  if (has_upper_lb()) {
    if (!this->upper_lb().IsInitialized()) return false;
  }
  if (has_upper_rb()) {
    if (!this->upper_rb().IsInitialized()) return false;
  }
  if (has_upper_rt()) {
    if (!this->upper_rt().IsInitialized()) return false;
  }
  return true;
}

void Box3D::Swap(Box3D* other) {
  if (other != this) {
    std::swap(lower_lt_, other->lower_lt_);
    std::swap(lower_lb_, other->lower_lb_);
    std::swap(lower_rb_, other->lower_rb_);
    std::swap(lower_rt_, other->lower_rt_);
    std::swap(upper_lt_, other->upper_lt_);
    std::swap(upper_lb_, other->upper_lb_);
    std::swap(upper_rb_, other->upper_rb_);
    std::swap(upper_rt_, other->upper_rt_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Box3D::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Box3D_descriptor_;
  metadata.reflection = Box3D_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SkeletonPoint::kPtFieldNumber;
const int SkeletonPoint::kValidFieldNumber;
#endif  // !_MSC_VER

SkeletonPoint::SkeletonPoint()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.SkeletonPoint)
}

void SkeletonPoint::InitAsDefaultInstance() {
  pt_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
}

SkeletonPoint::SkeletonPoint(const SkeletonPoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.SkeletonPoint)
}

void SkeletonPoint::SharedCtor() {
  _cached_size_ = 0;
  pt_ = NULL;
  valid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SkeletonPoint::~SkeletonPoint() {
  // @@protoc_insertion_point(destructor:CommonProto.SkeletonPoint)
  SharedDtor();
}

void SkeletonPoint::SharedDtor() {
  if (this != default_instance_) {
    delete pt_;
  }
}

void SkeletonPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SkeletonPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SkeletonPoint_descriptor_;
}

const SkeletonPoint& SkeletonPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

SkeletonPoint* SkeletonPoint::default_instance_ = NULL;

SkeletonPoint* SkeletonPoint::New() const {
  return new SkeletonPoint;
}

void SkeletonPoint::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_pt()) {
      if (pt_ != NULL) pt_->::CommonProto::Point::Clear();
    }
    valid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SkeletonPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.SkeletonPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .CommonProto.Point pt = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pt()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_valid;
        break;
      }

      // required int32 valid = 2;
      case 2: {
        if (tag == 16) {
         parse_valid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &valid_)));
          set_has_valid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.SkeletonPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.SkeletonPoint)
  return false;
#undef DO_
}

void SkeletonPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.SkeletonPoint)
  // required .CommonProto.Point pt = 1;
  if (has_pt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pt(), output);
  }

  // required int32 valid = 2;
  if (has_valid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->valid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.SkeletonPoint)
}

::google::protobuf::uint8* SkeletonPoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.SkeletonPoint)
  // required .CommonProto.Point pt = 1;
  if (has_pt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pt(), target);
  }

  // required int32 valid = 2;
  if (has_valid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->valid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.SkeletonPoint)
  return target;
}

int SkeletonPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .CommonProto.Point pt = 1;
    if (has_pt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pt());
    }

    // required int32 valid = 2;
    if (has_valid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->valid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SkeletonPoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SkeletonPoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SkeletonPoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SkeletonPoint::MergeFrom(const SkeletonPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pt()) {
      mutable_pt()->::CommonProto::Point::MergeFrom(from.pt());
    }
    if (from.has_valid()) {
      set_valid(from.valid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SkeletonPoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SkeletonPoint::CopyFrom(const SkeletonPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SkeletonPoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_pt()) {
    if (!this->pt().IsInitialized()) return false;
  }
  return true;
}

void SkeletonPoint::Swap(SkeletonPoint* other) {
  if (other != this) {
    std::swap(pt_, other->pt_);
    std::swap(valid_, other->valid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SkeletonPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SkeletonPoint_descriptor_;
  metadata.reflection = SkeletonPoint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Image::kWidthFieldNumber;
const int Image::kHeightFieldNumber;
const int Image::kChannelFieldNumber;
const int Image::kTimeStampFieldNumber;
const int Image::kSendModeFieldNumber;
const int Image::kFormatFieldNumber;
const int Image::kIndexFieldNumber;
const int Image::kCountFieldNumber;
const int Image::kDepthFieldNumber;
const int Image::kAlignFieldNumber;
const int Image::kImageCounterFieldNumber;
#endif  // !_MSC_VER

Image::Image()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Image)
}

void Image::InitAsDefaultInstance() {
}

Image::Image(const Image& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Image)
}

void Image::SharedCtor() {
  _cached_size_ = 0;
  width_ = 0;
  height_ = 0;
  channel_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  send_mode_ = 0;
  format_ = 0;
  index_ = 0;
  count_ = 0;
  depth_ = 0;
  align_ = 0;
  image_counter_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:CommonProto.Image)
  SharedDtor();
}

void Image::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_descriptor_;
}

const Image& Image::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New() const {
  return new Image;
}

void Image::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Image*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(width_, count_);
  }
  ZR_(depth_, image_counter_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Image)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 width = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_height;
        break;
      }

      // required int32 height = 2;
      case 2: {
        if (tag == 16) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_channel;
        break;
      }

      // required int32 channel = 3;
      case 3: {
        if (tag == 24) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_time_stamp;
        break;
      }

      // optional int64 time_stamp = 4;
      case 4: {
        if (tag == 32) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_send_mode;
        break;
      }

      // optional int32 send_mode = 5;
      case 5: {
        if (tag == 40) {
         parse_send_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &send_mode_)));
          set_has_send_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_format;
        break;
      }

      // optional int32 format = 6;
      case 6: {
        if (tag == 48) {
         parse_format:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &format_)));
          set_has_format();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_index;
        break;
      }

      // optional int32 index = 7;
      case 7: {
        if (tag == 56) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_count;
        break;
      }

      // optional int32 count = 8;
      case 8: {
        if (tag == 64) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_depth;
        break;
      }

      // optional int32 depth = 9;
      case 9: {
        if (tag == 72) {
         parse_depth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &depth_)));
          set_has_depth();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_align;
        break;
      }

      // optional int32 align = 10;
      case 10: {
        if (tag == 80) {
         parse_align:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &align_)));
          set_has_align();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_image_counter;
        break;
      }

      // optional int32 image_counter = 11;
      case 11: {
        if (tag == 88) {
         parse_image_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &image_counter_)));
          set_has_image_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Image)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Image)
  return false;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Image)
  // required int32 width = 1;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->width(), output);
  }

  // required int32 height = 2;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->height(), output);
  }

  // required int32 channel = 3;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->channel(), output);
  }

  // optional int64 time_stamp = 4;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->time_stamp(), output);
  }

  // optional int32 send_mode = 5;
  if (has_send_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->send_mode(), output);
  }

  // optional int32 format = 6;
  if (has_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->format(), output);
  }

  // optional int32 index = 7;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->index(), output);
  }

  // optional int32 count = 8;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->count(), output);
  }

  // optional int32 depth = 9;
  if (has_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->depth(), output);
  }

  // optional int32 align = 10;
  if (has_align()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->align(), output);
  }

  // optional int32 image_counter = 11;
  if (has_image_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->image_counter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Image)
}

::google::protobuf::uint8* Image::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Image)
  // required int32 width = 1;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->width(), target);
  }

  // required int32 height = 2;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->height(), target);
  }

  // required int32 channel = 3;
  if (has_channel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->channel(), target);
  }

  // optional int64 time_stamp = 4;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->time_stamp(), target);
  }

  // optional int32 send_mode = 5;
  if (has_send_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->send_mode(), target);
  }

  // optional int32 format = 6;
  if (has_format()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->format(), target);
  }

  // optional int32 index = 7;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->index(), target);
  }

  // optional int32 count = 8;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->count(), target);
  }

  // optional int32 depth = 9;
  if (has_depth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->depth(), target);
  }

  // optional int32 align = 10;
  if (has_align()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->align(), target);
  }

  // optional int32 image_counter = 11;
  if (has_image_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->image_counter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Image)
  return target;
}

int Image::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 width = 1;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }

    // required int32 height = 2;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }

    // required int32 channel = 3;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel());
    }

    // optional int64 time_stamp = 4;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional int32 send_mode = 5;
    if (has_send_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->send_mode());
    }

    // optional int32 format = 6;
    if (has_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->format());
    }

    // optional int32 index = 7;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional int32 count = 8;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 depth = 9;
    if (has_depth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->depth());
    }

    // optional int32 align = 10;
    if (has_align()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->align());
    }

    // optional int32 image_counter = 11;
    if (has_image_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->image_counter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Image* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Image*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_send_mode()) {
      set_send_mode(from.send_mode());
    }
    if (from.has_format()) {
      set_format(from.format());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_depth()) {
      set_depth(from.depth());
    }
    if (from.has_align()) {
      set_align(from.align());
    }
    if (from.has_image_counter()) {
      set_image_counter(from.image_counter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Image::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Image::Swap(Image* other) {
  if (other != this) {
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(channel_, other->channel_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(send_mode_, other->send_mode_);
    std::swap(format_, other->format_);
    std::swap(index_, other->index_);
    std::swap(count_, other->count_);
    std::swap(depth_, other->depth_);
    std::swap(align_, other->align_);
    std::swap(image_counter_, other->image_counter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Image::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_descriptor_;
  metadata.reflection = Image_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Velocity::kVxFieldNumber;
const int Velocity::kVyFieldNumber;
const int Velocity::kVzFieldNumber;
#endif  // !_MSC_VER

Velocity::Velocity()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Velocity)
}

void Velocity::InitAsDefaultInstance() {
}

Velocity::Velocity(const Velocity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Velocity)
}

void Velocity::SharedCtor() {
  _cached_size_ = 0;
  vx_ = 0;
  vy_ = 0;
  vz_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Velocity::~Velocity() {
  // @@protoc_insertion_point(destructor:CommonProto.Velocity)
  SharedDtor();
}

void Velocity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Velocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Velocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Velocity_descriptor_;
}

const Velocity& Velocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Velocity* Velocity::default_instance_ = NULL;

Velocity* Velocity::New() const {
  return new Velocity;
}

void Velocity::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Velocity*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(vx_, vz_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Velocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Velocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float vx = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vx_)));
          set_has_vx();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_vy;
        break;
      }

      // required float vy = 2;
      case 2: {
        if (tag == 21) {
         parse_vy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vy_)));
          set_has_vy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_vz;
        break;
      }

      // optional float vz = 3;
      case 3: {
        if (tag == 29) {
         parse_vz:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vz_)));
          set_has_vz();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Velocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Velocity)
  return false;
#undef DO_
}

void Velocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Velocity)
  // required float vx = 1;
  if (has_vx()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->vx(), output);
  }

  // required float vy = 2;
  if (has_vy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->vy(), output);
  }

  // optional float vz = 3;
  if (has_vz()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->vz(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Velocity)
}

::google::protobuf::uint8* Velocity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Velocity)
  // required float vx = 1;
  if (has_vx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->vx(), target);
  }

  // required float vy = 2;
  if (has_vy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->vy(), target);
  }

  // optional float vz = 3;
  if (has_vz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->vz(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Velocity)
  return target;
}

int Velocity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float vx = 1;
    if (has_vx()) {
      total_size += 1 + 4;
    }

    // required float vy = 2;
    if (has_vy()) {
      total_size += 1 + 4;
    }

    // optional float vz = 3;
    if (has_vz()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Velocity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Velocity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Velocity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Velocity::MergeFrom(const Velocity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_vx()) {
      set_vx(from.vx());
    }
    if (from.has_vy()) {
      set_vy(from.vy());
    }
    if (from.has_vz()) {
      set_vz(from.vz());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Velocity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Velocity::CopyFrom(const Velocity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Velocity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Velocity::Swap(Velocity* other) {
  if (other != this) {
    std::swap(vx_, other->vx_);
    std::swap(vy_, other->vy_);
    std::swap(vz_, other->vz_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Velocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Velocity_descriptor_;
  metadata.reflection = Velocity_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Line_EndPointType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Line_EndPointType_descriptor_;
}
bool Line_EndPointType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Line_EndPointType Line::EndPointType_Far;
const Line_EndPointType Line::EndPointType_Near;
const Line_EndPointType Line::EndPointType_MIN;
const Line_EndPointType Line::EndPointType_MAX;
const int Line::EndPointType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Line::kIdFieldNumber;
const int Line::kLifeTimeFieldNumber;
const int Line::kCoeffsFieldNumber;
const int Line::kEndPointsFieldNumber;
const int Line::kTypeFieldNumber;
const int Line::kSourceFieldNumber;
const int Line::kContoursFieldNumber;
const int Line::kDistToFrontWheelFieldNumber;
const int Line::kWidthFieldNumber;
const int Line::kTypeSiblingFieldNumber;
const int Line::kConfFieldNumber;
const int Line::kSigmaCoeffsFieldNumber;
#endif  // !_MSC_VER

Line::Line()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Line)
}

void Line::InitAsDefaultInstance() {
}

Line::Line(const Line& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Line)
}

void Line::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  life_time_ = 0;
  type_ = 0;
  source_ = 0;
  dist_to_front_wheel_ = 0;
  width_ = 0;
  type_sibling_ = 0;
  conf_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Line::~Line() {
  // @@protoc_insertion_point(destructor:CommonProto.Line)
  SharedDtor();
}

void Line::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Line::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Line::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Line_descriptor_;
}

const Line& Line::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Line* Line::default_instance_ = NULL;

Line* Line::New() const {
  return new Line;
}

void Line::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Line*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 179) {
    ZR_(id_, life_time_);
    ZR_(type_, source_);
    dist_to_front_wheel_ = 0;
  }
  ZR_(width_, conf_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  coeffs_.Clear();
  end_points_.Clear();
  contours_.Clear();
  sigma_coeffs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Line::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Line)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_life_time;
        break;
      }

      // optional int32 life_time = 3;
      case 3: {
        if (tag == 24) {
         parse_life_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &life_time_)));
          set_has_life_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_coeffs;
        break;
      }

      // repeated float coeffs = 7;
      case 7: {
        if (tag == 61) {
         parse_coeffs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 61, input, this->mutable_coeffs())));
        } else if (tag == 58) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_coeffs())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_coeffs;
        if (input->ExpectTag(66)) goto parse_end_points;
        break;
      }

      // repeated .CommonProto.Point end_points = 8;
      case 8: {
        if (tag == 66) {
         parse_end_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_end_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_end_points;
        if (input->ExpectTag(72)) goto parse_type;
        break;
      }

      // optional int32 type = 9;
      case 9: {
        if (tag == 72) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_source;
        break;
      }

      // optional int32 source = 10;
      case 10: {
        if (tag == 80) {
         parse_source:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &source_)));
          set_has_source();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_contours;
        break;
      }

      // repeated .CommonProto.Contour contours = 11;
      case 11: {
        if (tag == 90) {
         parse_contours:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_contours()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_contours;
        if (input->ExpectTag(101)) goto parse_dist_to_front_wheel;
        break;
      }

      // optional float dist_to_front_wheel = 12;
      case 12: {
        if (tag == 101) {
         parse_dist_to_front_wheel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dist_to_front_wheel_)));
          set_has_dist_to_front_wheel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(109)) goto parse_width;
        break;
      }

      // optional float width = 13;
      case 13: {
        if (tag == 109) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_type_sibling;
        break;
      }

      // optional int32 type_sibling = 14;
      case 14: {
        if (tag == 112) {
         parse_type_sibling:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_sibling_)));
          set_has_type_sibling();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(125)) goto parse_conf;
        break;
      }

      // optional float conf = 15;
      case 15: {
        if (tag == 125) {
         parse_conf:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_)));
          set_has_conf();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(165)) goto parse_sigma_coeffs;
        break;
      }

      // repeated float sigma_coeffs = 20;
      case 20: {
        if (tag == 165) {
         parse_sigma_coeffs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 165, input, this->mutable_sigma_coeffs())));
        } else if (tag == 162) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_sigma_coeffs())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(165)) goto parse_sigma_coeffs;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Line)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Line)
  return false;
#undef DO_
}

void Line::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Line)
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 life_time = 3;
  if (has_life_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->life_time(), output);
  }

  // repeated float coeffs = 7;
  for (int i = 0; i < this->coeffs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      7, this->coeffs(i), output);
  }

  // repeated .CommonProto.Point end_points = 8;
  for (int i = 0; i < this->end_points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->end_points(i), output);
  }

  // optional int32 type = 9;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->type(), output);
  }

  // optional int32 source = 10;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->source(), output);
  }

  // repeated .CommonProto.Contour contours = 11;
  for (int i = 0; i < this->contours_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->contours(i), output);
  }

  // optional float dist_to_front_wheel = 12;
  if (has_dist_to_front_wheel()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->dist_to_front_wheel(), output);
  }

  // optional float width = 13;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->width(), output);
  }

  // optional int32 type_sibling = 14;
  if (has_type_sibling()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->type_sibling(), output);
  }

  // optional float conf = 15;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->conf(), output);
  }

  // repeated float sigma_coeffs = 20;
  for (int i = 0; i < this->sigma_coeffs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      20, this->sigma_coeffs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Line)
}

::google::protobuf::uint8* Line::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Line)
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 life_time = 3;
  if (has_life_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->life_time(), target);
  }

  // repeated float coeffs = 7;
  for (int i = 0; i < this->coeffs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(7, this->coeffs(i), target);
  }

  // repeated .CommonProto.Point end_points = 8;
  for (int i = 0; i < this->end_points_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->end_points(i), target);
  }

  // optional int32 type = 9;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->type(), target);
  }

  // optional int32 source = 10;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->source(), target);
  }

  // repeated .CommonProto.Contour contours = 11;
  for (int i = 0; i < this->contours_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->contours(i), target);
  }

  // optional float dist_to_front_wheel = 12;
  if (has_dist_to_front_wheel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->dist_to_front_wheel(), target);
  }

  // optional float width = 13;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->width(), target);
  }

  // optional int32 type_sibling = 14;
  if (has_type_sibling()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->type_sibling(), target);
  }

  // optional float conf = 15;
  if (has_conf()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(15, this->conf(), target);
  }

  // repeated float sigma_coeffs = 20;
  for (int i = 0; i < this->sigma_coeffs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(20, this->sigma_coeffs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Line)
  return target;
}

int Line::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 life_time = 3;
    if (has_life_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->life_time());
    }

    // optional int32 type = 9;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 source = 10;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->source());
    }

    // optional float dist_to_front_wheel = 12;
    if (has_dist_to_front_wheel()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float width = 13;
    if (has_width()) {
      total_size += 1 + 4;
    }

    // optional int32 type_sibling = 14;
    if (has_type_sibling()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type_sibling());
    }

    // optional float conf = 15;
    if (has_conf()) {
      total_size += 1 + 4;
    }

  }
  // repeated float coeffs = 7;
  {
    int data_size = 0;
    data_size = 4 * this->coeffs_size();
    total_size += 1 * this->coeffs_size() + data_size;
  }

  // repeated .CommonProto.Point end_points = 8;
  total_size += 1 * this->end_points_size();
  for (int i = 0; i < this->end_points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->end_points(i));
  }

  // repeated .CommonProto.Contour contours = 11;
  total_size += 1 * this->contours_size();
  for (int i = 0; i < this->contours_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->contours(i));
  }

  // repeated float sigma_coeffs = 20;
  {
    int data_size = 0;
    data_size = 4 * this->sigma_coeffs_size();
    total_size += 2 * this->sigma_coeffs_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Line::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Line* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Line*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Line::MergeFrom(const Line& from) {
  GOOGLE_CHECK_NE(&from, this);
  coeffs_.MergeFrom(from.coeffs_);
  end_points_.MergeFrom(from.end_points_);
  contours_.MergeFrom(from.contours_);
  sigma_coeffs_.MergeFrom(from.sigma_coeffs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_life_time()) {
      set_life_time(from.life_time());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_source()) {
      set_source(from.source());
    }
    if (from.has_dist_to_front_wheel()) {
      set_dist_to_front_wheel(from.dist_to_front_wheel());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_type_sibling()) {
      set_type_sibling(from.type_sibling());
    }
    if (from.has_conf()) {
      set_conf(from.conf());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Line::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Line::CopyFrom(const Line& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Line::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->end_points())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->contours())) return false;
  return true;
}

void Line::Swap(Line* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(life_time_, other->life_time_);
    coeffs_.Swap(&other->coeffs_);
    end_points_.Swap(&other->end_points_);
    std::swap(type_, other->type_);
    std::swap(source_, other->source_);
    contours_.Swap(&other->contours_);
    std::swap(dist_to_front_wheel_, other->dist_to_front_wheel_);
    std::swap(width_, other->width_);
    std::swap(type_sibling_, other->type_sibling_);
    std::swap(conf_, other->conf_);
    sigma_coeffs_.Swap(&other->sigma_coeffs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Line::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Line_descriptor_;
  metadata.reflection = Line_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Lines::kCamIdFieldNumber;
const int Lines::kLinesFieldNumber;
#endif  // !_MSC_VER

Lines::Lines()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Lines)
}

void Lines::InitAsDefaultInstance() {
}

Lines::Lines(const Lines& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Lines)
}

void Lines::SharedCtor() {
  _cached_size_ = 0;
  cam_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Lines::~Lines() {
  // @@protoc_insertion_point(destructor:CommonProto.Lines)
  SharedDtor();
}

void Lines::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Lines::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Lines::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Lines_descriptor_;
}

const Lines& Lines::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Lines* Lines::default_instance_ = NULL;

Lines* Lines::New() const {
  return new Lines;
}

void Lines::Clear() {
  cam_id_ = 0;
  lines_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Lines::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Lines)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cam_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cam_id_)));
          set_has_cam_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_lines;
        break;
      }

      // repeated .CommonProto.Line lines = 2;
      case 2: {
        if (tag == 18) {
         parse_lines:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lines()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_lines;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Lines)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Lines)
  return false;
#undef DO_
}

void Lines::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Lines)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->cam_id(), output);
  }

  // repeated .CommonProto.Line lines = 2;
  for (int i = 0; i < this->lines_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->lines(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Lines)
}

::google::protobuf::uint8* Lines::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Lines)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->cam_id(), target);
  }

  // repeated .CommonProto.Line lines = 2;
  for (int i = 0; i < this->lines_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->lines(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Lines)
  return target;
}

int Lines::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 cam_id = 1;
    if (has_cam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cam_id());
    }

  }
  // repeated .CommonProto.Line lines = 2;
  total_size += 1 * this->lines_size();
  for (int i = 0; i < this->lines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lines(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Lines::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Lines* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Lines*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Lines::MergeFrom(const Lines& from) {
  GOOGLE_CHECK_NE(&from, this);
  lines_.MergeFrom(from.lines_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cam_id()) {
      set_cam_id(from.cam_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Lines::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Lines::CopyFrom(const Lines& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lines::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->lines())) return false;
  return true;
}

void Lines::Swap(Lines* other) {
  if (other != this) {
    std::swap(cam_id_, other->cam_id_);
    lines_.Swap(&other->lines_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Lines::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Lines_descriptor_;
  metadata.reflection = Lines_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WorldSpaceInfo::kYawFieldNumber;
const int WorldSpaceInfo::kVelFieldNumber;
const int WorldSpaceInfo::kLengthFieldNumber;
const int WorldSpaceInfo::kWidthFieldNumber;
const int WorldSpaceInfo::kHeightFieldNumber;
const int WorldSpaceInfo::kPolyFieldNumber;
const int WorldSpaceInfo::kPositionFieldNumber;
const int WorldSpaceInfo::kTraversableFieldNumber;
const int WorldSpaceInfo::kHmwFieldNumber;
const int WorldSpaceInfo::kTtcFieldNumber;
const int WorldSpaceInfo::kCurrLaneFieldNumber;
const int WorldSpaceInfo::kPositionObsFieldNumber;
const int WorldSpaceInfo::kSigmaYawFieldNumber;
const int WorldSpaceInfo::kSigmaVelFieldNumber;
const int WorldSpaceInfo::kSigmaWidthFieldNumber;
const int WorldSpaceInfo::kSigmaHeightFieldNumber;
const int WorldSpaceInfo::kSigmaPositionFieldNumber;
#endif  // !_MSC_VER

WorldSpaceInfo::WorldSpaceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.WorldSpaceInfo)
}

void WorldSpaceInfo::InitAsDefaultInstance() {
  vel_ = const_cast< ::CommonProto::Velocity*>(&::CommonProto::Velocity::default_instance());
  poly_ = const_cast< ::CommonProto::Polygon*>(&::CommonProto::Polygon::default_instance());
  position_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
  position_obs_ = const_cast< ::CommonProto::Point*>(&::CommonProto::Point::default_instance());
}

WorldSpaceInfo::WorldSpaceInfo(const WorldSpaceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.WorldSpaceInfo)
}

void WorldSpaceInfo::SharedCtor() {
  _cached_size_ = 0;
  yaw_ = 0;
  vel_ = NULL;
  length_ = 0;
  width_ = 0;
  height_ = 0;
  poly_ = NULL;
  position_ = NULL;
  traversable_ = 0;
  hmw_ = 0;
  ttc_ = 0;
  curr_lane_ = 0;
  position_obs_ = NULL;
  sigma_yaw_ = 0;
  sigma_width_ = 0;
  sigma_height_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WorldSpaceInfo::~WorldSpaceInfo() {
  // @@protoc_insertion_point(destructor:CommonProto.WorldSpaceInfo)
  SharedDtor();
}

void WorldSpaceInfo::SharedDtor() {
  if (this != default_instance_) {
    delete vel_;
    delete poly_;
    delete position_;
    delete position_obs_;
  }
}

void WorldSpaceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WorldSpaceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WorldSpaceInfo_descriptor_;
}

const WorldSpaceInfo& WorldSpaceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

WorldSpaceInfo* WorldSpaceInfo::default_instance_ = NULL;

WorldSpaceInfo* WorldSpaceInfo::New() const {
  return new WorldSpaceInfo;
}

void WorldSpaceInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<WorldSpaceInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(yaw_, height_);
    if (has_vel()) {
      if (vel_ != NULL) vel_->::CommonProto::Velocity::Clear();
    }
    if (has_poly()) {
      if (poly_ != NULL) poly_->::CommonProto::Polygon::Clear();
    }
    if (has_position()) {
      if (position_ != NULL) position_->::CommonProto::Point::Clear();
    }
    traversable_ = 0;
  }
  if (_has_bits_[8 / 32] & 57088) {
    ZR_(hmw_, curr_lane_);
    ZR_(sigma_yaw_, sigma_width_);
    if (has_position_obs()) {
      if (position_obs_ != NULL) position_obs_->::CommonProto::Point::Clear();
    }
    sigma_height_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  sigma_vel_.Clear();
  sigma_position_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WorldSpaceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.WorldSpaceInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float yaw = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_)));
          set_has_yaw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vel;
        break;
      }

      // optional .CommonProto.Velocity vel = 2;
      case 2: {
        if (tag == 18) {
         parse_vel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vel()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_length;
        break;
      }

      // optional float length = 3;
      case 3: {
        if (tag == 29) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_width;
        break;
      }

      // optional float width = 4;
      case 4: {
        if (tag == 37) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_height;
        break;
      }

      // optional float height = 5;
      case 5: {
        if (tag == 45) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_poly;
        break;
      }

      // optional .CommonProto.Polygon poly = 6;
      case 6: {
        if (tag == 50) {
         parse_poly:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_poly()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_position;
        break;
      }

      // optional .CommonProto.Point position = 7;
      case 7: {
        if (tag == 58) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_traversable;
        break;
      }

      // optional int32 traversable = 8;
      case 8: {
        if (tag == 64) {
         parse_traversable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &traversable_)));
          set_has_traversable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_hmw;
        break;
      }

      // optional float hmw = 9;
      case 9: {
        if (tag == 77) {
         parse_hmw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &hmw_)));
          set_has_hmw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_ttc;
        break;
      }

      // optional float ttc = 10;
      case 10: {
        if (tag == 85) {
         parse_ttc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ttc_)));
          set_has_ttc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_curr_lane;
        break;
      }

      // optional int32 curr_lane = 11;
      case 11: {
        if (tag == 88) {
         parse_curr_lane:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &curr_lane_)));
          set_has_curr_lane();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_position_obs;
        break;
      }

      // optional .CommonProto.Point position_obs = 12;
      case 12: {
        if (tag == 98) {
         parse_position_obs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position_obs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(245)) goto parse_sigma_yaw;
        break;
      }

      // optional float sigma_yaw = 30;
      case 30: {
        if (tag == 245) {
         parse_sigma_yaw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sigma_yaw_)));
          set_has_sigma_yaw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(253)) goto parse_sigma_vel;
        break;
      }

      // repeated float sigma_vel = 31;
      case 31: {
        if (tag == 253) {
         parse_sigma_vel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 253, input, this->mutable_sigma_vel())));
        } else if (tag == 250) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_sigma_vel())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(253)) goto parse_sigma_vel;
        if (input->ExpectTag(261)) goto parse_sigma_width;
        break;
      }

      // optional float sigma_width = 32;
      case 32: {
        if (tag == 261) {
         parse_sigma_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sigma_width_)));
          set_has_sigma_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(269)) goto parse_sigma_height;
        break;
      }

      // optional float sigma_height = 33;
      case 33: {
        if (tag == 269) {
         parse_sigma_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sigma_height_)));
          set_has_sigma_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(277)) goto parse_sigma_position;
        break;
      }

      // repeated float sigma_position = 34;
      case 34: {
        if (tag == 277) {
         parse_sigma_position:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 277, input, this->mutable_sigma_position())));
        } else if (tag == 274) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_sigma_position())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(277)) goto parse_sigma_position;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.WorldSpaceInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.WorldSpaceInfo)
  return false;
#undef DO_
}

void WorldSpaceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.WorldSpaceInfo)
  // optional float yaw = 1;
  if (has_yaw()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->yaw(), output);
  }

  // optional .CommonProto.Velocity vel = 2;
  if (has_vel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->vel(), output);
  }

  // optional float length = 3;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->length(), output);
  }

  // optional float width = 4;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->width(), output);
  }

  // optional float height = 5;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->height(), output);
  }

  // optional .CommonProto.Polygon poly = 6;
  if (has_poly()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->poly(), output);
  }

  // optional .CommonProto.Point position = 7;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->position(), output);
  }

  // optional int32 traversable = 8;
  if (has_traversable()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->traversable(), output);
  }

  // optional float hmw = 9;
  if (has_hmw()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->hmw(), output);
  }

  // optional float ttc = 10;
  if (has_ttc()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->ttc(), output);
  }

  // optional int32 curr_lane = 11;
  if (has_curr_lane()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->curr_lane(), output);
  }

  // optional .CommonProto.Point position_obs = 12;
  if (has_position_obs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->position_obs(), output);
  }

  // optional float sigma_yaw = 30;
  if (has_sigma_yaw()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(30, this->sigma_yaw(), output);
  }

  // repeated float sigma_vel = 31;
  for (int i = 0; i < this->sigma_vel_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      31, this->sigma_vel(i), output);
  }

  // optional float sigma_width = 32;
  if (has_sigma_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(32, this->sigma_width(), output);
  }

  // optional float sigma_height = 33;
  if (has_sigma_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(33, this->sigma_height(), output);
  }

  // repeated float sigma_position = 34;
  for (int i = 0; i < this->sigma_position_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      34, this->sigma_position(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.WorldSpaceInfo)
}

::google::protobuf::uint8* WorldSpaceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.WorldSpaceInfo)
  // optional float yaw = 1;
  if (has_yaw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->yaw(), target);
  }

  // optional .CommonProto.Velocity vel = 2;
  if (has_vel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->vel(), target);
  }

  // optional float length = 3;
  if (has_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->length(), target);
  }

  // optional float width = 4;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->width(), target);
  }

  // optional float height = 5;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->height(), target);
  }

  // optional .CommonProto.Polygon poly = 6;
  if (has_poly()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->poly(), target);
  }

  // optional .CommonProto.Point position = 7;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->position(), target);
  }

  // optional int32 traversable = 8;
  if (has_traversable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->traversable(), target);
  }

  // optional float hmw = 9;
  if (has_hmw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->hmw(), target);
  }

  // optional float ttc = 10;
  if (has_ttc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->ttc(), target);
  }

  // optional int32 curr_lane = 11;
  if (has_curr_lane()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->curr_lane(), target);
  }

  // optional .CommonProto.Point position_obs = 12;
  if (has_position_obs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->position_obs(), target);
  }

  // optional float sigma_yaw = 30;
  if (has_sigma_yaw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(30, this->sigma_yaw(), target);
  }

  // repeated float sigma_vel = 31;
  for (int i = 0; i < this->sigma_vel_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(31, this->sigma_vel(i), target);
  }

  // optional float sigma_width = 32;
  if (has_sigma_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(32, this->sigma_width(), target);
  }

  // optional float sigma_height = 33;
  if (has_sigma_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(33, this->sigma_height(), target);
  }

  // repeated float sigma_position = 34;
  for (int i = 0; i < this->sigma_position_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(34, this->sigma_position(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.WorldSpaceInfo)
  return target;
}

int WorldSpaceInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float yaw = 1;
    if (has_yaw()) {
      total_size += 1 + 4;
    }

    // optional .CommonProto.Velocity vel = 2;
    if (has_vel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vel());
    }

    // optional float length = 3;
    if (has_length()) {
      total_size += 1 + 4;
    }

    // optional float width = 4;
    if (has_width()) {
      total_size += 1 + 4;
    }

    // optional float height = 5;
    if (has_height()) {
      total_size += 1 + 4;
    }

    // optional .CommonProto.Polygon poly = 6;
    if (has_poly()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->poly());
    }

    // optional .CommonProto.Point position = 7;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }

    // optional int32 traversable = 8;
    if (has_traversable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->traversable());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float hmw = 9;
    if (has_hmw()) {
      total_size += 1 + 4;
    }

    // optional float ttc = 10;
    if (has_ttc()) {
      total_size += 1 + 4;
    }

    // optional int32 curr_lane = 11;
    if (has_curr_lane()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->curr_lane());
    }

    // optional .CommonProto.Point position_obs = 12;
    if (has_position_obs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position_obs());
    }

    // optional float sigma_yaw = 30;
    if (has_sigma_yaw()) {
      total_size += 2 + 4;
    }

    // optional float sigma_width = 32;
    if (has_sigma_width()) {
      total_size += 2 + 4;
    }

    // optional float sigma_height = 33;
    if (has_sigma_height()) {
      total_size += 2 + 4;
    }

  }
  // repeated float sigma_vel = 31;
  {
    int data_size = 0;
    data_size = 4 * this->sigma_vel_size();
    total_size += 2 * this->sigma_vel_size() + data_size;
  }

  // repeated float sigma_position = 34;
  {
    int data_size = 0;
    data_size = 4 * this->sigma_position_size();
    total_size += 2 * this->sigma_position_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WorldSpaceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WorldSpaceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WorldSpaceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WorldSpaceInfo::MergeFrom(const WorldSpaceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  sigma_vel_.MergeFrom(from.sigma_vel_);
  sigma_position_.MergeFrom(from.sigma_position_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_yaw()) {
      set_yaw(from.yaw());
    }
    if (from.has_vel()) {
      mutable_vel()->::CommonProto::Velocity::MergeFrom(from.vel());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_poly()) {
      mutable_poly()->::CommonProto::Polygon::MergeFrom(from.poly());
    }
    if (from.has_position()) {
      mutable_position()->::CommonProto::Point::MergeFrom(from.position());
    }
    if (from.has_traversable()) {
      set_traversable(from.traversable());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_hmw()) {
      set_hmw(from.hmw());
    }
    if (from.has_ttc()) {
      set_ttc(from.ttc());
    }
    if (from.has_curr_lane()) {
      set_curr_lane(from.curr_lane());
    }
    if (from.has_position_obs()) {
      mutable_position_obs()->::CommonProto::Point::MergeFrom(from.position_obs());
    }
    if (from.has_sigma_yaw()) {
      set_sigma_yaw(from.sigma_yaw());
    }
    if (from.has_sigma_width()) {
      set_sigma_width(from.sigma_width());
    }
    if (from.has_sigma_height()) {
      set_sigma_height(from.sigma_height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WorldSpaceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WorldSpaceInfo::CopyFrom(const WorldSpaceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WorldSpaceInfo::IsInitialized() const {

  if (has_vel()) {
    if (!this->vel().IsInitialized()) return false;
  }
  if (has_poly()) {
    if (!this->poly().IsInitialized()) return false;
  }
  if (has_position()) {
    if (!this->position().IsInitialized()) return false;
  }
  if (has_position_obs()) {
    if (!this->position_obs().IsInitialized()) return false;
  }
  return true;
}

void WorldSpaceInfo::Swap(WorldSpaceInfo* other) {
  if (other != this) {
    std::swap(yaw_, other->yaw_);
    std::swap(vel_, other->vel_);
    std::swap(length_, other->length_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(poly_, other->poly_);
    std::swap(position_, other->position_);
    std::swap(traversable_, other->traversable_);
    std::swap(hmw_, other->hmw_);
    std::swap(ttc_, other->ttc_);
    std::swap(curr_lane_, other->curr_lane_);
    std::swap(position_obs_, other->position_obs_);
    std::swap(sigma_yaw_, other->sigma_yaw_);
    sigma_vel_.Swap(&other->sigma_vel_);
    std::swap(sigma_width_, other->sigma_width_);
    std::swap(sigma_height_, other->sigma_height_);
    sigma_position_.Swap(&other->sigma_position_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WorldSpaceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WorldSpaceInfo_descriptor_;
  metadata.reflection = WorldSpaceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImageSpaceInfo::kRectFieldNumber;
const int ImageSpaceInfo::kSkeletonFieldNumber;
const int ImageSpaceInfo::kBoxFieldNumber;
const int ImageSpaceInfo::kPolyFieldNumber;
const int ImageSpaceInfo::kSigmaWidthFieldNumber;
const int ImageSpaceInfo::kSigmaHeightFieldNumber;
const int ImageSpaceInfo::kSigmaXFieldNumber;
const int ImageSpaceInfo::kSigmaYFieldNumber;
#endif  // !_MSC_VER

ImageSpaceInfo::ImageSpaceInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.ImageSpaceInfo)
}

void ImageSpaceInfo::InitAsDefaultInstance() {
  rect_ = const_cast< ::CommonProto::Rect*>(&::CommonProto::Rect::default_instance());
  skeleton_ = const_cast< ::CommonProto::Skeleton*>(&::CommonProto::Skeleton::default_instance());
  box_ = const_cast< ::CommonProto::Box3D*>(&::CommonProto::Box3D::default_instance());
  poly_ = const_cast< ::CommonProto::Polygon*>(&::CommonProto::Polygon::default_instance());
}

ImageSpaceInfo::ImageSpaceInfo(const ImageSpaceInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.ImageSpaceInfo)
}

void ImageSpaceInfo::SharedCtor() {
  _cached_size_ = 0;
  rect_ = NULL;
  skeleton_ = NULL;
  box_ = NULL;
  poly_ = NULL;
  sigma_width_ = 0;
  sigma_height_ = 0;
  sigma_x_ = 0;
  sigma_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImageSpaceInfo::~ImageSpaceInfo() {
  // @@protoc_insertion_point(destructor:CommonProto.ImageSpaceInfo)
  SharedDtor();
}

void ImageSpaceInfo::SharedDtor() {
  if (this != default_instance_) {
    delete rect_;
    delete skeleton_;
    delete box_;
    delete poly_;
  }
}

void ImageSpaceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImageSpaceInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImageSpaceInfo_descriptor_;
}

const ImageSpaceInfo& ImageSpaceInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

ImageSpaceInfo* ImageSpaceInfo::default_instance_ = NULL;

ImageSpaceInfo* ImageSpaceInfo::New() const {
  return new ImageSpaceInfo;
}

void ImageSpaceInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ImageSpaceInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(sigma_width_, sigma_y_);
    if (has_rect()) {
      if (rect_ != NULL) rect_->::CommonProto::Rect::Clear();
    }
    if (has_skeleton()) {
      if (skeleton_ != NULL) skeleton_->::CommonProto::Skeleton::Clear();
    }
    if (has_box()) {
      if (box_ != NULL) box_->::CommonProto::Box3D::Clear();
    }
    if (has_poly()) {
      if (poly_ != NULL) poly_->::CommonProto::Polygon::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImageSpaceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.ImageSpaceInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CommonProto.Rect rect = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rect()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_skeleton;
        break;
      }

      // optional .CommonProto.Skeleton skeleton = 10;
      case 10: {
        if (tag == 82) {
         parse_skeleton:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_skeleton()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_box;
        break;
      }

      // optional .CommonProto.Box3D box = 11;
      case 11: {
        if (tag == 90) {
         parse_box:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_box()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_poly;
        break;
      }

      // optional .CommonProto.Polygon poly = 12;
      case 12: {
        if (tag == 98) {
         parse_poly:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_poly()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(165)) goto parse_sigma_width;
        break;
      }

      // optional float sigma_width = 20;
      case 20: {
        if (tag == 165) {
         parse_sigma_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sigma_width_)));
          set_has_sigma_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(173)) goto parse_sigma_height;
        break;
      }

      // optional float sigma_height = 21;
      case 21: {
        if (tag == 173) {
         parse_sigma_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sigma_height_)));
          set_has_sigma_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(181)) goto parse_sigma_x;
        break;
      }

      // optional float sigma_x = 22;
      case 22: {
        if (tag == 181) {
         parse_sigma_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sigma_x_)));
          set_has_sigma_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(189)) goto parse_sigma_y;
        break;
      }

      // optional float sigma_y = 23;
      case 23: {
        if (tag == 189) {
         parse_sigma_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sigma_y_)));
          set_has_sigma_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.ImageSpaceInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.ImageSpaceInfo)
  return false;
#undef DO_
}

void ImageSpaceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.ImageSpaceInfo)
  // optional .CommonProto.Rect rect = 1;
  if (has_rect()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->rect(), output);
  }

  // optional .CommonProto.Skeleton skeleton = 10;
  if (has_skeleton()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->skeleton(), output);
  }

  // optional .CommonProto.Box3D box = 11;
  if (has_box()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->box(), output);
  }

  // optional .CommonProto.Polygon poly = 12;
  if (has_poly()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->poly(), output);
  }

  // optional float sigma_width = 20;
  if (has_sigma_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(20, this->sigma_width(), output);
  }

  // optional float sigma_height = 21;
  if (has_sigma_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(21, this->sigma_height(), output);
  }

  // optional float sigma_x = 22;
  if (has_sigma_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(22, this->sigma_x(), output);
  }

  // optional float sigma_y = 23;
  if (has_sigma_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(23, this->sigma_y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.ImageSpaceInfo)
}

::google::protobuf::uint8* ImageSpaceInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.ImageSpaceInfo)
  // optional .CommonProto.Rect rect = 1;
  if (has_rect()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->rect(), target);
  }

  // optional .CommonProto.Skeleton skeleton = 10;
  if (has_skeleton()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->skeleton(), target);
  }

  // optional .CommonProto.Box3D box = 11;
  if (has_box()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->box(), target);
  }

  // optional .CommonProto.Polygon poly = 12;
  if (has_poly()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->poly(), target);
  }

  // optional float sigma_width = 20;
  if (has_sigma_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(20, this->sigma_width(), target);
  }

  // optional float sigma_height = 21;
  if (has_sigma_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(21, this->sigma_height(), target);
  }

  // optional float sigma_x = 22;
  if (has_sigma_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(22, this->sigma_x(), target);
  }

  // optional float sigma_y = 23;
  if (has_sigma_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(23, this->sigma_y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.ImageSpaceInfo)
  return target;
}

int ImageSpaceInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CommonProto.Rect rect = 1;
    if (has_rect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rect());
    }

    // optional .CommonProto.Skeleton skeleton = 10;
    if (has_skeleton()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->skeleton());
    }

    // optional .CommonProto.Box3D box = 11;
    if (has_box()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->box());
    }

    // optional .CommonProto.Polygon poly = 12;
    if (has_poly()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->poly());
    }

    // optional float sigma_width = 20;
    if (has_sigma_width()) {
      total_size += 2 + 4;
    }

    // optional float sigma_height = 21;
    if (has_sigma_height()) {
      total_size += 2 + 4;
    }

    // optional float sigma_x = 22;
    if (has_sigma_x()) {
      total_size += 2 + 4;
    }

    // optional float sigma_y = 23;
    if (has_sigma_y()) {
      total_size += 2 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageSpaceInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImageSpaceInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImageSpaceInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImageSpaceInfo::MergeFrom(const ImageSpaceInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rect()) {
      mutable_rect()->::CommonProto::Rect::MergeFrom(from.rect());
    }
    if (from.has_skeleton()) {
      mutable_skeleton()->::CommonProto::Skeleton::MergeFrom(from.skeleton());
    }
    if (from.has_box()) {
      mutable_box()->::CommonProto::Box3D::MergeFrom(from.box());
    }
    if (from.has_poly()) {
      mutable_poly()->::CommonProto::Polygon::MergeFrom(from.poly());
    }
    if (from.has_sigma_width()) {
      set_sigma_width(from.sigma_width());
    }
    if (from.has_sigma_height()) {
      set_sigma_height(from.sigma_height());
    }
    if (from.has_sigma_x()) {
      set_sigma_x(from.sigma_x());
    }
    if (from.has_sigma_y()) {
      set_sigma_y(from.sigma_y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImageSpaceInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImageSpaceInfo::CopyFrom(const ImageSpaceInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageSpaceInfo::IsInitialized() const {

  if (has_rect()) {
    if (!this->rect().IsInitialized()) return false;
  }
  if (has_skeleton()) {
    if (!this->skeleton().IsInitialized()) return false;
  }
  if (has_box()) {
    if (!this->box().IsInitialized()) return false;
  }
  if (has_poly()) {
    if (!this->poly().IsInitialized()) return false;
  }
  return true;
}

void ImageSpaceInfo::Swap(ImageSpaceInfo* other) {
  if (other != this) {
    std::swap(rect_, other->rect_);
    std::swap(skeleton_, other->skeleton_);
    std::swap(box_, other->box_);
    std::swap(poly_, other->poly_);
    std::swap(sigma_width_, other->sigma_width_);
    std::swap(sigma_height_, other->sigma_height_);
    std::swap(sigma_x_, other->sigma_x_);
    std::swap(sigma_y_, other->sigma_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImageSpaceInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImageSpaceInfo_descriptor_;
  metadata.reflection = ImageSpaceInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Obstacle::kIdFieldNumber;
const int Obstacle::kTypeFieldNumber;
const int Obstacle::kConfFieldNumber;
const int Obstacle::kLifeTimeFieldNumber;
const int Obstacle::kAgeFieldNumber;
const int Obstacle::kImgInfoFieldNumber;
const int Obstacle::kWorldInfoFieldNumber;
const int Obstacle::kPropertyFieldNumber;
const int Obstacle::kPropertyNameFieldNumber;
const int Obstacle::kPropertyTypeFieldNumber;
const int Obstacle::kPropertyConfFieldNumber;
#endif  // !_MSC_VER

Obstacle::Obstacle()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Obstacle)
}

void Obstacle::InitAsDefaultInstance() {
  img_info_ = const_cast< ::CommonProto::ImageSpaceInfo*>(&::CommonProto::ImageSpaceInfo::default_instance());
  world_info_ = const_cast< ::CommonProto::WorldSpaceInfo*>(&::CommonProto::WorldSpaceInfo::default_instance());
}

Obstacle::Obstacle(const Obstacle& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Obstacle)
}

void Obstacle::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0;
  type_ = 0;
  conf_ = 0;
  life_time_ = 0;
  age_ = 0;
  img_info_ = NULL;
  world_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Obstacle::~Obstacle() {
  // @@protoc_insertion_point(destructor:CommonProto.Obstacle)
  SharedDtor();
}

void Obstacle::SharedDtor() {
  if (this != default_instance_) {
    delete img_info_;
    delete world_info_;
  }
}

void Obstacle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Obstacle::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Obstacle_descriptor_;
}

const Obstacle& Obstacle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Obstacle* Obstacle::default_instance_ = NULL;

Obstacle* Obstacle::New() const {
  return new Obstacle;
}

void Obstacle::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Obstacle*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(id_, life_time_);
    age_ = 0;
    if (has_img_info()) {
      if (img_info_ != NULL) img_info_->::CommonProto::ImageSpaceInfo::Clear();
    }
    if (has_world_info()) {
      if (world_info_ != NULL) world_info_->::CommonProto::WorldSpaceInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  property_.Clear();
  property_name_.Clear();
  property_type_.Clear();
  property_conf_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Obstacle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Obstacle)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required int32 type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_conf;
        break;
      }

      // optional int32 conf = 3;
      case 3: {
        if (tag == 24) {
         parse_conf:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &conf_)));
          set_has_conf();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_life_time;
        break;
      }

      // optional int32 life_time = 4;
      case 4: {
        if (tag == 32) {
         parse_life_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &life_time_)));
          set_has_life_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_age;
        break;
      }

      // optional int32 age = 5;
      case 5: {
        if (tag == 40) {
         parse_age:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &age_)));
          set_has_age();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_img_info;
        break;
      }

      // optional .CommonProto.ImageSpaceInfo img_info = 6;
      case 6: {
        if (tag == 50) {
         parse_img_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_img_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_world_info;
        break;
      }

      // optional .CommonProto.WorldSpaceInfo world_info = 7;
      case 7: {
        if (tag == 58) {
         parse_world_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_world_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_property;
        break;
      }

      // repeated int32 property = 13;
      case 13: {
        if (tag == 104) {
         parse_property:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 104, input, this->mutable_property())));
        } else if (tag == 106) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_property())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_property;
        if (input->ExpectTag(114)) goto parse_property_name;
        break;
      }

      // repeated string property_name = 14;
      case 14: {
        if (tag == 114) {
         parse_property_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_property_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->property_name(this->property_name_size() - 1).data(),
            this->property_name(this->property_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "property_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_property_name;
        if (input->ExpectTag(120)) goto parse_property_type;
        break;
      }

      // repeated int32 property_type = 15;
      case 15: {
        if (tag == 120) {
         parse_property_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 120, input, this->mutable_property_type())));
        } else if (tag == 122) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_property_type())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_property_type;
        if (input->ExpectTag(133)) goto parse_property_conf;
        break;
      }

      // repeated float property_conf = 16;
      case 16: {
        if (tag == 133) {
         parse_property_conf:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 2, 133, input, this->mutable_property_conf())));
        } else if (tag == 130) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_property_conf())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(133)) goto parse_property_conf;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Obstacle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Obstacle)
  return false;
#undef DO_
}

void Obstacle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Obstacle)
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // optional int32 conf = 3;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->conf(), output);
  }

  // optional int32 life_time = 4;
  if (has_life_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->life_time(), output);
  }

  // optional int32 age = 5;
  if (has_age()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->age(), output);
  }

  // optional .CommonProto.ImageSpaceInfo img_info = 6;
  if (has_img_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->img_info(), output);
  }

  // optional .CommonProto.WorldSpaceInfo world_info = 7;
  if (has_world_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->world_info(), output);
  }

  // repeated int32 property = 13;
  for (int i = 0; i < this->property_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      13, this->property(i), output);
  }

  // repeated string property_name = 14;
  for (int i = 0; i < this->property_name_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->property_name(i).data(), this->property_name(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "property_name");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->property_name(i), output);
  }

  // repeated int32 property_type = 15;
  for (int i = 0; i < this->property_type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      15, this->property_type(i), output);
  }

  // repeated float property_conf = 16;
  for (int i = 0; i < this->property_conf_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      16, this->property_conf(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Obstacle)
}

::google::protobuf::uint8* Obstacle::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Obstacle)
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // required int32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->type(), target);
  }

  // optional int32 conf = 3;
  if (has_conf()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->conf(), target);
  }

  // optional int32 life_time = 4;
  if (has_life_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->life_time(), target);
  }

  // optional int32 age = 5;
  if (has_age()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->age(), target);
  }

  // optional .CommonProto.ImageSpaceInfo img_info = 6;
  if (has_img_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->img_info(), target);
  }

  // optional .CommonProto.WorldSpaceInfo world_info = 7;
  if (has_world_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->world_info(), target);
  }

  // repeated int32 property = 13;
  for (int i = 0; i < this->property_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(13, this->property(i), target);
  }

  // repeated string property_name = 14;
  for (int i = 0; i < this->property_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->property_name(i).data(), this->property_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "property_name");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(14, this->property_name(i), target);
  }

  // repeated int32 property_type = 15;
  for (int i = 0; i < this->property_type_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(15, this->property_type(i), target);
  }

  // repeated float property_conf = 16;
  for (int i = 0; i < this->property_conf_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(16, this->property_conf(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Obstacle)
  return target;
}

int Obstacle::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 conf = 3;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->conf());
    }

    // optional int32 life_time = 4;
    if (has_life_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->life_time());
    }

    // optional int32 age = 5;
    if (has_age()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->age());
    }

    // optional .CommonProto.ImageSpaceInfo img_info = 6;
    if (has_img_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->img_info());
    }

    // optional .CommonProto.WorldSpaceInfo world_info = 7;
    if (has_world_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->world_info());
    }

  }
  // repeated int32 property = 13;
  {
    int data_size = 0;
    for (int i = 0; i < this->property_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->property(i));
    }
    total_size += 1 * this->property_size() + data_size;
  }

  // repeated string property_name = 14;
  total_size += 1 * this->property_name_size();
  for (int i = 0; i < this->property_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->property_name(i));
  }

  // repeated int32 property_type = 15;
  {
    int data_size = 0;
    for (int i = 0; i < this->property_type_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->property_type(i));
    }
    total_size += 1 * this->property_type_size() + data_size;
  }

  // repeated float property_conf = 16;
  {
    int data_size = 0;
    data_size = 4 * this->property_conf_size();
    total_size += 2 * this->property_conf_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Obstacle::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Obstacle* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Obstacle*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Obstacle::MergeFrom(const Obstacle& from) {
  GOOGLE_CHECK_NE(&from, this);
  property_.MergeFrom(from.property_);
  property_name_.MergeFrom(from.property_name_);
  property_type_.MergeFrom(from.property_type_);
  property_conf_.MergeFrom(from.property_conf_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_conf()) {
      set_conf(from.conf());
    }
    if (from.has_life_time()) {
      set_life_time(from.life_time());
    }
    if (from.has_age()) {
      set_age(from.age());
    }
    if (from.has_img_info()) {
      mutable_img_info()->::CommonProto::ImageSpaceInfo::MergeFrom(from.img_info());
    }
    if (from.has_world_info()) {
      mutable_world_info()->::CommonProto::WorldSpaceInfo::MergeFrom(from.world_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Obstacle::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle::CopyFrom(const Obstacle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_img_info()) {
    if (!this->img_info().IsInitialized()) return false;
  }
  if (has_world_info()) {
    if (!this->world_info().IsInitialized()) return false;
  }
  return true;
}

void Obstacle::Swap(Obstacle* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(conf_, other->conf_);
    std::swap(life_time_, other->life_time_);
    std::swap(age_, other->age_);
    std::swap(img_info_, other->img_info_);
    std::swap(world_info_, other->world_info_);
    property_.Swap(&other->property_);
    property_name_.Swap(&other->property_name_);
    property_type_.Swap(&other->property_type_);
    property_conf_.Swap(&other->property_conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Obstacle::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Obstacle_descriptor_;
  metadata.reflection = Obstacle_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Obstacles::kCamIdFieldNumber;
const int Obstacles::kObstacleFieldNumber;
const int Obstacles::kConfScaleFieldNumber;
#endif  // !_MSC_VER

Obstacles::Obstacles()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Obstacles)
}

void Obstacles::InitAsDefaultInstance() {
}

Obstacles::Obstacles(const Obstacles& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Obstacles)
}

void Obstacles::SharedCtor() {
  _cached_size_ = 0;
  cam_id_ = 0;
  conf_scale_ = 0.1f;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Obstacles::~Obstacles() {
  // @@protoc_insertion_point(destructor:CommonProto.Obstacles)
  SharedDtor();
}

void Obstacles::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Obstacles::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Obstacles::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Obstacles_descriptor_;
}

const Obstacles& Obstacles::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Obstacles* Obstacles::default_instance_ = NULL;

Obstacles* Obstacles::New() const {
  return new Obstacles;
}

void Obstacles::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    cam_id_ = 0;
    conf_scale_ = 0.1f;
  }
  obstacle_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Obstacles::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Obstacles)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cam_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cam_id_)));
          set_has_cam_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_obstacle;
        break;
      }

      // repeated .CommonProto.Obstacle obstacle = 2;
      case 2: {
        if (tag == 18) {
         parse_obstacle:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_obstacle()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_obstacle;
        if (input->ExpectTag(29)) goto parse_conf_scale;
        break;
      }

      // optional float conf_scale = 3 [default = 0.1];
      case 3: {
        if (tag == 29) {
         parse_conf_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_scale_)));
          set_has_conf_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Obstacles)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Obstacles)
  return false;
#undef DO_
}

void Obstacles::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Obstacles)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->cam_id(), output);
  }

  // repeated .CommonProto.Obstacle obstacle = 2;
  for (int i = 0; i < this->obstacle_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->obstacle(i), output);
  }

  // optional float conf_scale = 3 [default = 0.1];
  if (has_conf_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->conf_scale(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Obstacles)
}

::google::protobuf::uint8* Obstacles::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Obstacles)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->cam_id(), target);
  }

  // repeated .CommonProto.Obstacle obstacle = 2;
  for (int i = 0; i < this->obstacle_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->obstacle(i), target);
  }

  // optional float conf_scale = 3 [default = 0.1];
  if (has_conf_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->conf_scale(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Obstacles)
  return target;
}

int Obstacles::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 cam_id = 1;
    if (has_cam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cam_id());
    }

    // optional float conf_scale = 3 [default = 0.1];
    if (has_conf_scale()) {
      total_size += 1 + 4;
    }

  }
  // repeated .CommonProto.Obstacle obstacle = 2;
  total_size += 1 * this->obstacle_size();
  for (int i = 0; i < this->obstacle_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->obstacle(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Obstacles::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Obstacles* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Obstacles*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Obstacles::MergeFrom(const Obstacles& from) {
  GOOGLE_CHECK_NE(&from, this);
  obstacle_.MergeFrom(from.obstacle_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cam_id()) {
      set_cam_id(from.cam_id());
    }
    if (from.has_conf_scale()) {
      set_conf_scale(from.conf_scale());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Obstacles::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacles::CopyFrom(const Obstacles& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacles::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->obstacle())) return false;
  return true;
}

void Obstacles::Swap(Obstacles* other) {
  if (other != this) {
    std::swap(cam_id_, other->cam_id_);
    obstacle_.Swap(&other->obstacle_);
    std::swap(conf_scale_, other->conf_scale_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Obstacles::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Obstacles_descriptor_;
  metadata.reflection = Obstacles_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FeatureMap::kDataFieldNumber;
#endif  // !_MSC_VER

FeatureMap::FeatureMap()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.FeatureMap)
}

void FeatureMap::InitAsDefaultInstance() {
}

FeatureMap::FeatureMap(const FeatureMap& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.FeatureMap)
}

void FeatureMap::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FeatureMap::~FeatureMap() {
  // @@protoc_insertion_point(destructor:CommonProto.FeatureMap)
  SharedDtor();
}

void FeatureMap::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void FeatureMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FeatureMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FeatureMap_descriptor_;
}

const FeatureMap& FeatureMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

FeatureMap* FeatureMap::default_instance_ = NULL;

FeatureMap* FeatureMap::New() const {
  return new FeatureMap;
}

void FeatureMap::Clear() {
  if (has_data()) {
    if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      data_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FeatureMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.FeatureMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.FeatureMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.FeatureMap)
  return false;
#undef DO_
}

void FeatureMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.FeatureMap)
  // required bytes data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.FeatureMap)
}

::google::protobuf::uint8* FeatureMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.FeatureMap)
  // required bytes data = 1;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.FeatureMap)
  return target;
}

int FeatureMap::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FeatureMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FeatureMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FeatureMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FeatureMap::MergeFrom(const FeatureMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FeatureMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FeatureMap::CopyFrom(const FeatureMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FeatureMap::Swap(FeatureMap* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FeatureMap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FeatureMap_descriptor_;
  metadata.reflection = FeatureMap_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ObstacleRaw::kRectFieldNumber;
const int ObstacleRaw::kConfFieldNumber;
const int ObstacleRaw::kModelFieldNumber;
const int ObstacleRaw::kSourceFieldNumber;
const int ObstacleRaw::kPropertyFieldNumber;
const int ObstacleRaw::kPropertyNameFieldNumber;
const int ObstacleRaw::kPropertyTypeFieldNumber;
const int ObstacleRaw::kPropertyConfFieldNumber;
#endif  // !_MSC_VER

ObstacleRaw::ObstacleRaw()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.ObstacleRaw)
}

void ObstacleRaw::InitAsDefaultInstance() {
  rect_ = const_cast< ::CommonProto::Rect*>(&::CommonProto::Rect::default_instance());
}

ObstacleRaw::ObstacleRaw(const ObstacleRaw& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.ObstacleRaw)
}

void ObstacleRaw::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  rect_ = NULL;
  conf_ = 0;
  model_ = 0;
  source_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ObstacleRaw::~ObstacleRaw() {
  // @@protoc_insertion_point(destructor:CommonProto.ObstacleRaw)
  SharedDtor();
}

void ObstacleRaw::SharedDtor() {
  if (this != default_instance_) {
    delete rect_;
  }
}

void ObstacleRaw::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ObstacleRaw::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ObstacleRaw_descriptor_;
}

const ObstacleRaw& ObstacleRaw::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

ObstacleRaw* ObstacleRaw::default_instance_ = NULL;

ObstacleRaw* ObstacleRaw::New() const {
  return new ObstacleRaw;
}

void ObstacleRaw::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ObstacleRaw*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(conf_, model_);
    if (has_rect()) {
      if (rect_ != NULL) rect_->::CommonProto::Rect::Clear();
    }
    source_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  property_.Clear();
  property_name_.Clear();
  property_type_.Clear();
  property_conf_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ObstacleRaw::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.ObstacleRaw)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .CommonProto.Rect rect = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rect()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_conf;
        break;
      }

      // required float conf = 2;
      case 2: {
        if (tag == 21) {
         parse_conf:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_)));
          set_has_conf();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_model;
        break;
      }

      // required int32 model = 3;
      case 3: {
        if (tag == 24) {
         parse_model:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &model_)));
          set_has_model();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_source;
        break;
      }

      // optional int32 source = 4;
      case 4: {
        if (tag == 32) {
         parse_source:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &source_)));
          set_has_source();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_property;
        break;
      }

      // repeated int32 property = 6;
      case 6: {
        if (tag == 48) {
         parse_property:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 48, input, this->mutable_property())));
        } else if (tag == 50) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_property())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_property;
        if (input->ExpectTag(58)) goto parse_property_name;
        break;
      }

      // repeated string property_name = 7;
      case 7: {
        if (tag == 58) {
         parse_property_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_property_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->property_name(this->property_name_size() - 1).data(),
            this->property_name(this->property_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "property_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_property_name;
        if (input->ExpectTag(64)) goto parse_property_type;
        break;
      }

      // repeated int32 property_type = 8;
      case 8: {
        if (tag == 64) {
         parse_property_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 64, input, this->mutable_property_type())));
        } else if (tag == 66) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_property_type())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_property_type;
        if (input->ExpectTag(77)) goto parse_property_conf;
        break;
      }

      // repeated float property_conf = 9;
      case 9: {
        if (tag == 77) {
         parse_property_conf:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 77, input, this->mutable_property_conf())));
        } else if (tag == 74) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_property_conf())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_property_conf;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.ObstacleRaw)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.ObstacleRaw)
  return false;
#undef DO_
}

void ObstacleRaw::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.ObstacleRaw)
  // required .CommonProto.Rect rect = 1;
  if (has_rect()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->rect(), output);
  }

  // required float conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->conf(), output);
  }

  // required int32 model = 3;
  if (has_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->model(), output);
  }

  // optional int32 source = 4;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->source(), output);
  }

  // repeated int32 property = 6;
  for (int i = 0; i < this->property_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      6, this->property(i), output);
  }

  // repeated string property_name = 7;
  for (int i = 0; i < this->property_name_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
    this->property_name(i).data(), this->property_name(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE,
    "property_name");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->property_name(i), output);
  }

  // repeated int32 property_type = 8;
  for (int i = 0; i < this->property_type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      8, this->property_type(i), output);
  }

  // repeated float property_conf = 9;
  for (int i = 0; i < this->property_conf_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      9, this->property_conf(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.ObstacleRaw)
}

::google::protobuf::uint8* ObstacleRaw::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.ObstacleRaw)
  // required .CommonProto.Rect rect = 1;
  if (has_rect()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->rect(), target);
  }

  // required float conf = 2;
  if (has_conf()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->conf(), target);
  }

  // required int32 model = 3;
  if (has_model()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->model(), target);
  }

  // optional int32 source = 4;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->source(), target);
  }

  // repeated int32 property = 6;
  for (int i = 0; i < this->property_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(6, this->property(i), target);
  }

  // repeated string property_name = 7;
  for (int i = 0; i < this->property_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->property_name(i).data(), this->property_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "property_name");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(7, this->property_name(i), target);
  }

  // repeated int32 property_type = 8;
  for (int i = 0; i < this->property_type_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(8, this->property_type(i), target);
  }

  // repeated float property_conf = 9;
  for (int i = 0; i < this->property_conf_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(9, this->property_conf(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.ObstacleRaw)
  return target;
}

int ObstacleRaw::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .CommonProto.Rect rect = 1;
    if (has_rect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rect());
    }

    // required float conf = 2;
    if (has_conf()) {
      total_size += 1 + 4;
    }

    // required int32 model = 3;
    if (has_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->model());
    }

    // optional int32 source = 4;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->source());
    }

  }
  // repeated int32 property = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->property_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->property(i));
    }
    total_size += 1 * this->property_size() + data_size;
  }

  // repeated string property_name = 7;
  total_size += 1 * this->property_name_size();
  for (int i = 0; i < this->property_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->property_name(i));
  }

  // repeated int32 property_type = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->property_type_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->property_type(i));
    }
    total_size += 1 * this->property_type_size() + data_size;
  }

  // repeated float property_conf = 9;
  {
    int data_size = 0;
    data_size = 4 * this->property_conf_size();
    total_size += 1 * this->property_conf_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ObstacleRaw::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ObstacleRaw* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ObstacleRaw*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ObstacleRaw::MergeFrom(const ObstacleRaw& from) {
  GOOGLE_CHECK_NE(&from, this);
  property_.MergeFrom(from.property_);
  property_name_.MergeFrom(from.property_name_);
  property_type_.MergeFrom(from.property_type_);
  property_conf_.MergeFrom(from.property_conf_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rect()) {
      mutable_rect()->::CommonProto::Rect::MergeFrom(from.rect());
    }
    if (from.has_conf()) {
      set_conf(from.conf());
    }
    if (from.has_model()) {
      set_model(from.model());
    }
    if (from.has_source()) {
      set_source(from.source());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ObstacleRaw::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObstacleRaw::CopyFrom(const ObstacleRaw& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleRaw::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_rect()) {
    if (!this->rect().IsInitialized()) return false;
  }
  return true;
}

void ObstacleRaw::Swap(ObstacleRaw* other) {
  if (other != this) {
    std::swap(rect_, other->rect_);
    std::swap(conf_, other->conf_);
    std::swap(model_, other->model_);
    std::swap(source_, other->source_);
    property_.Swap(&other->property_);
    property_name_.Swap(&other->property_name_);
    property_type_.Swap(&other->property_type_);
    property_conf_.Swap(&other->property_conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ObstacleRaw::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ObstacleRaw_descriptor_;
  metadata.reflection = ObstacleRaw_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ObstacleRaws::kCamIdFieldNumber;
const int ObstacleRaws::kObstacleFieldNumber;
const int ObstacleRaws::kConfScaleFieldNumber;
#endif  // !_MSC_VER

ObstacleRaws::ObstacleRaws()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.ObstacleRaws)
}

void ObstacleRaws::InitAsDefaultInstance() {
}

ObstacleRaws::ObstacleRaws(const ObstacleRaws& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.ObstacleRaws)
}

void ObstacleRaws::SharedCtor() {
  _cached_size_ = 0;
  cam_id_ = 0;
  conf_scale_ = 0.1f;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ObstacleRaws::~ObstacleRaws() {
  // @@protoc_insertion_point(destructor:CommonProto.ObstacleRaws)
  SharedDtor();
}

void ObstacleRaws::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ObstacleRaws::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ObstacleRaws::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ObstacleRaws_descriptor_;
}

const ObstacleRaws& ObstacleRaws::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

ObstacleRaws* ObstacleRaws::default_instance_ = NULL;

ObstacleRaws* ObstacleRaws::New() const {
  return new ObstacleRaws;
}

void ObstacleRaws::Clear() {
  if (_has_bits_[0 / 32] & 5) {
    cam_id_ = 0;
    conf_scale_ = 0.1f;
  }
  obstacle_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ObstacleRaws::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.ObstacleRaws)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cam_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cam_id_)));
          set_has_cam_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_obstacle;
        break;
      }

      // repeated .CommonProto.ObstacleRaw obstacle = 2;
      case 2: {
        if (tag == 18) {
         parse_obstacle:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_obstacle()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_obstacle;
        if (input->ExpectTag(29)) goto parse_conf_scale;
        break;
      }

      // optional float conf_scale = 3 [default = 0.1];
      case 3: {
        if (tag == 29) {
         parse_conf_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_scale_)));
          set_has_conf_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.ObstacleRaws)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.ObstacleRaws)
  return false;
#undef DO_
}

void ObstacleRaws::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.ObstacleRaws)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->cam_id(), output);
  }

  // repeated .CommonProto.ObstacleRaw obstacle = 2;
  for (int i = 0; i < this->obstacle_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->obstacle(i), output);
  }

  // optional float conf_scale = 3 [default = 0.1];
  if (has_conf_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->conf_scale(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.ObstacleRaws)
}

::google::protobuf::uint8* ObstacleRaws::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.ObstacleRaws)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->cam_id(), target);
  }

  // repeated .CommonProto.ObstacleRaw obstacle = 2;
  for (int i = 0; i < this->obstacle_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->obstacle(i), target);
  }

  // optional float conf_scale = 3 [default = 0.1];
  if (has_conf_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->conf_scale(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.ObstacleRaws)
  return target;
}

int ObstacleRaws::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 cam_id = 1;
    if (has_cam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cam_id());
    }

    // optional float conf_scale = 3 [default = 0.1];
    if (has_conf_scale()) {
      total_size += 1 + 4;
    }

  }
  // repeated .CommonProto.ObstacleRaw obstacle = 2;
  total_size += 1 * this->obstacle_size();
  for (int i = 0; i < this->obstacle_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->obstacle(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ObstacleRaws::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ObstacleRaws* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ObstacleRaws*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ObstacleRaws::MergeFrom(const ObstacleRaws& from) {
  GOOGLE_CHECK_NE(&from, this);
  obstacle_.MergeFrom(from.obstacle_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cam_id()) {
      set_cam_id(from.cam_id());
    }
    if (from.has_conf_scale()) {
      set_conf_scale(from.conf_scale());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ObstacleRaws::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ObstacleRaws::CopyFrom(const ObstacleRaws& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObstacleRaws::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->obstacle())) return false;
  return true;
}

void ObstacleRaws::Swap(ObstacleRaws* other) {
  if (other != this) {
    std::swap(cam_id_, other->cam_id_);
    obstacle_.Swap(&other->obstacle_);
    std::swap(conf_scale_, other->conf_scale_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ObstacleRaws::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ObstacleRaws_descriptor_;
  metadata.reflection = ObstacleRaws_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FreeSpacePoints::kPropertyFieldNumber;
const int FreeSpacePoints::kCamIdFieldNumber;
const int FreeSpacePoints::kPtsVcsFieldNumber;
const int FreeSpacePoints::kPtsImgFieldNumber;
#endif  // !_MSC_VER

FreeSpacePoints::FreeSpacePoints()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.FreeSpacePoints)
}

void FreeSpacePoints::InitAsDefaultInstance() {
}

FreeSpacePoints::FreeSpacePoints(const FreeSpacePoints& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.FreeSpacePoints)
}

void FreeSpacePoints::SharedCtor() {
  _cached_size_ = 0;
  cam_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FreeSpacePoints::~FreeSpacePoints() {
  // @@protoc_insertion_point(destructor:CommonProto.FreeSpacePoints)
  SharedDtor();
}

void FreeSpacePoints::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FreeSpacePoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FreeSpacePoints::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FreeSpacePoints_descriptor_;
}

const FreeSpacePoints& FreeSpacePoints::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

FreeSpacePoints* FreeSpacePoints::default_instance_ = NULL;

FreeSpacePoints* FreeSpacePoints::New() const {
  return new FreeSpacePoints;
}

void FreeSpacePoints::Clear() {
  cam_id_ = 0;
  property_.Clear();
  pts_vcs_.Clear();
  pts_img_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FreeSpacePoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.FreeSpacePoints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 property = 3;
      case 3: {
        if (tag == 24) {
         parse_property:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_property())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_property())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_property;
        if (input->ExpectTag(32)) goto parse_cam_id;
        break;
      }

      // optional int32 cam_id = 4;
      case 4: {
        if (tag == 32) {
         parse_cam_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cam_id_)));
          set_has_cam_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_pts_vcs;
        break;
      }

      // repeated .CommonProto.Point pts_vcs = 5;
      case 5: {
        if (tag == 42) {
         parse_pts_vcs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pts_vcs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_pts_vcs;
        if (input->ExpectTag(50)) goto parse_pts_img;
        break;
      }

      // repeated .CommonProto.Point pts_img = 6;
      case 6: {
        if (tag == 50) {
         parse_pts_img:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pts_img()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_pts_img;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.FreeSpacePoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.FreeSpacePoints)
  return false;
#undef DO_
}

void FreeSpacePoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.FreeSpacePoints)
  // repeated int32 property = 3;
  for (int i = 0; i < this->property_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->property(i), output);
  }

  // optional int32 cam_id = 4;
  if (has_cam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->cam_id(), output);
  }

  // repeated .CommonProto.Point pts_vcs = 5;
  for (int i = 0; i < this->pts_vcs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->pts_vcs(i), output);
  }

  // repeated .CommonProto.Point pts_img = 6;
  for (int i = 0; i < this->pts_img_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->pts_img(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.FreeSpacePoints)
}

::google::protobuf::uint8* FreeSpacePoints::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.FreeSpacePoints)
  // repeated int32 property = 3;
  for (int i = 0; i < this->property_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->property(i), target);
  }

  // optional int32 cam_id = 4;
  if (has_cam_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->cam_id(), target);
  }

  // repeated .CommonProto.Point pts_vcs = 5;
  for (int i = 0; i < this->pts_vcs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->pts_vcs(i), target);
  }

  // repeated .CommonProto.Point pts_img = 6;
  for (int i = 0; i < this->pts_img_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->pts_img(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.FreeSpacePoints)
  return target;
}

int FreeSpacePoints::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 cam_id = 4;
    if (has_cam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cam_id());
    }

  }
  // repeated int32 property = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->property_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->property(i));
    }
    total_size += 1 * this->property_size() + data_size;
  }

  // repeated .CommonProto.Point pts_vcs = 5;
  total_size += 1 * this->pts_vcs_size();
  for (int i = 0; i < this->pts_vcs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pts_vcs(i));
  }

  // repeated .CommonProto.Point pts_img = 6;
  total_size += 1 * this->pts_img_size();
  for (int i = 0; i < this->pts_img_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pts_img(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FreeSpacePoints::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FreeSpacePoints* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FreeSpacePoints*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FreeSpacePoints::MergeFrom(const FreeSpacePoints& from) {
  GOOGLE_CHECK_NE(&from, this);
  property_.MergeFrom(from.property_);
  pts_vcs_.MergeFrom(from.pts_vcs_);
  pts_img_.MergeFrom(from.pts_img_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_cam_id()) {
      set_cam_id(from.cam_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FreeSpacePoints::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FreeSpacePoints::CopyFrom(const FreeSpacePoints& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FreeSpacePoints::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->pts_vcs())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->pts_img())) return false;
  return true;
}

void FreeSpacePoints::Swap(FreeSpacePoints* other) {
  if (other != this) {
    property_.Swap(&other->property_);
    std::swap(cam_id_, other->cam_id_);
    pts_vcs_.Swap(&other->pts_vcs_);
    pts_img_.Swap(&other->pts_img_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FreeSpacePoints::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FreeSpacePoints_descriptor_;
  metadata.reflection = FreeSpacePoints_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Box3DRaw::kPerceptFieldNumber;
const int Box3DRaw::kBoxFieldNumber;
#endif  // !_MSC_VER

Box3DRaw::Box3DRaw()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Box3DRaw)
}

void Box3DRaw::InitAsDefaultInstance() {
  percept_ = const_cast< ::CommonProto::ObstacleRaw*>(&::CommonProto::ObstacleRaw::default_instance());
  box_ = const_cast< ::CommonProto::Box3D*>(&::CommonProto::Box3D::default_instance());
}

Box3DRaw::Box3DRaw(const Box3DRaw& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Box3DRaw)
}

void Box3DRaw::SharedCtor() {
  _cached_size_ = 0;
  percept_ = NULL;
  box_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Box3DRaw::~Box3DRaw() {
  // @@protoc_insertion_point(destructor:CommonProto.Box3DRaw)
  SharedDtor();
}

void Box3DRaw::SharedDtor() {
  if (this != default_instance_) {
    delete percept_;
    delete box_;
  }
}

void Box3DRaw::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Box3DRaw::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Box3DRaw_descriptor_;
}

const Box3DRaw& Box3DRaw::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Box3DRaw* Box3DRaw::default_instance_ = NULL;

Box3DRaw* Box3DRaw::New() const {
  return new Box3DRaw;
}

void Box3DRaw::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_percept()) {
      if (percept_ != NULL) percept_->::CommonProto::ObstacleRaw::Clear();
    }
    if (has_box()) {
      if (box_ != NULL) box_->::CommonProto::Box3D::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Box3DRaw::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Box3DRaw)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .CommonProto.ObstacleRaw percept = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_percept()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_box;
        break;
      }

      // required .CommonProto.Box3D box = 2;
      case 2: {
        if (tag == 18) {
         parse_box:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_box()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Box3DRaw)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Box3DRaw)
  return false;
#undef DO_
}

void Box3DRaw::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Box3DRaw)
  // required .CommonProto.ObstacleRaw percept = 1;
  if (has_percept()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->percept(), output);
  }

  // required .CommonProto.Box3D box = 2;
  if (has_box()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->box(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Box3DRaw)
}

::google::protobuf::uint8* Box3DRaw::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Box3DRaw)
  // required .CommonProto.ObstacleRaw percept = 1;
  if (has_percept()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->percept(), target);
  }

  // required .CommonProto.Box3D box = 2;
  if (has_box()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->box(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Box3DRaw)
  return target;
}

int Box3DRaw::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .CommonProto.ObstacleRaw percept = 1;
    if (has_percept()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->percept());
    }

    // required .CommonProto.Box3D box = 2;
    if (has_box()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->box());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Box3DRaw::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Box3DRaw* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Box3DRaw*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Box3DRaw::MergeFrom(const Box3DRaw& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_percept()) {
      mutable_percept()->::CommonProto::ObstacleRaw::MergeFrom(from.percept());
    }
    if (from.has_box()) {
      mutable_box()->::CommonProto::Box3D::MergeFrom(from.box());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Box3DRaw::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Box3DRaw::CopyFrom(const Box3DRaw& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Box3DRaw::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_percept()) {
    if (!this->percept().IsInitialized()) return false;
  }
  if (has_box()) {
    if (!this->box().IsInitialized()) return false;
  }
  return true;
}

void Box3DRaw::Swap(Box3DRaw* other) {
  if (other != this) {
    std::swap(percept_, other->percept_);
    std::swap(box_, other->box_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Box3DRaw::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Box3DRaw_descriptor_;
  metadata.reflection = Box3DRaw_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Box3DRaws::kCamIdFieldNumber;
const int Box3DRaws::kBox3DFieldNumber;
#endif  // !_MSC_VER

Box3DRaws::Box3DRaws()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Box3DRaws)
}

void Box3DRaws::InitAsDefaultInstance() {
}

Box3DRaws::Box3DRaws(const Box3DRaws& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Box3DRaws)
}

void Box3DRaws::SharedCtor() {
  _cached_size_ = 0;
  cam_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Box3DRaws::~Box3DRaws() {
  // @@protoc_insertion_point(destructor:CommonProto.Box3DRaws)
  SharedDtor();
}

void Box3DRaws::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Box3DRaws::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Box3DRaws::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Box3DRaws_descriptor_;
}

const Box3DRaws& Box3DRaws::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Box3DRaws* Box3DRaws::default_instance_ = NULL;

Box3DRaws* Box3DRaws::New() const {
  return new Box3DRaws;
}

void Box3DRaws::Clear() {
  cam_id_ = 0;
  box_3d_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Box3DRaws::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Box3DRaws)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cam_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cam_id_)));
          set_has_cam_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_box_3d;
        break;
      }

      // repeated .CommonProto.Box3DRaw box_3d = 2;
      case 2: {
        if (tag == 18) {
         parse_box_3d:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_box_3d()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_box_3d;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Box3DRaws)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Box3DRaws)
  return false;
#undef DO_
}

void Box3DRaws::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Box3DRaws)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->cam_id(), output);
  }

  // repeated .CommonProto.Box3DRaw box_3d = 2;
  for (int i = 0; i < this->box_3d_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->box_3d(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Box3DRaws)
}

::google::protobuf::uint8* Box3DRaws::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Box3DRaws)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->cam_id(), target);
  }

  // repeated .CommonProto.Box3DRaw box_3d = 2;
  for (int i = 0; i < this->box_3d_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->box_3d(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Box3DRaws)
  return target;
}

int Box3DRaws::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 cam_id = 1;
    if (has_cam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cam_id());
    }

  }
  // repeated .CommonProto.Box3DRaw box_3d = 2;
  total_size += 1 * this->box_3d_size();
  for (int i = 0; i < this->box_3d_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->box_3d(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Box3DRaws::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Box3DRaws* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Box3DRaws*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Box3DRaws::MergeFrom(const Box3DRaws& from) {
  GOOGLE_CHECK_NE(&from, this);
  box_3d_.MergeFrom(from.box_3d_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cam_id()) {
      set_cam_id(from.cam_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Box3DRaws::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Box3DRaws::CopyFrom(const Box3DRaws& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Box3DRaws::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->box_3d())) return false;
  return true;
}

void Box3DRaws::Swap(Box3DRaws* other) {
  if (other != this) {
    std::swap(cam_id_, other->cam_id_);
    box_3d_.Swap(&other->box_3d_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Box3DRaws::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Box3DRaws_descriptor_;
  metadata.reflection = Box3DRaws_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Skeleton::kIdFieldNumber;
const int Skeleton::kSkeletonFieldNumber;
#endif  // !_MSC_VER

Skeleton::Skeleton()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Skeleton)
}

void Skeleton::InitAsDefaultInstance() {
}

Skeleton::Skeleton(const Skeleton& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Skeleton)
}

void Skeleton::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Skeleton::~Skeleton() {
  // @@protoc_insertion_point(destructor:CommonProto.Skeleton)
  SharedDtor();
}

void Skeleton::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Skeleton::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Skeleton::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Skeleton_descriptor_;
}

const Skeleton& Skeleton::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Skeleton* Skeleton::default_instance_ = NULL;

Skeleton* Skeleton::New() const {
  return new Skeleton;
}

void Skeleton::Clear() {
  id_ = 0;
  skeleton_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Skeleton::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Skeleton)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_skeleton;
        break;
      }

      // repeated .CommonProto.SkeletonPoint skeleton = 2;
      case 2: {
        if (tag == 18) {
         parse_skeleton:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_skeleton()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_skeleton;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Skeleton)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Skeleton)
  return false;
#undef DO_
}

void Skeleton::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Skeleton)
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // repeated .CommonProto.SkeletonPoint skeleton = 2;
  for (int i = 0; i < this->skeleton_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->skeleton(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Skeleton)
}

::google::protobuf::uint8* Skeleton::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Skeleton)
  // optional int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // repeated .CommonProto.SkeletonPoint skeleton = 2;
  for (int i = 0; i < this->skeleton_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->skeleton(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Skeleton)
  return target;
}

int Skeleton::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  // repeated .CommonProto.SkeletonPoint skeleton = 2;
  total_size += 1 * this->skeleton_size();
  for (int i = 0; i < this->skeleton_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->skeleton(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Skeleton::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Skeleton* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Skeleton*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Skeleton::MergeFrom(const Skeleton& from) {
  GOOGLE_CHECK_NE(&from, this);
  skeleton_.MergeFrom(from.skeleton_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Skeleton::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Skeleton::CopyFrom(const Skeleton& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Skeleton::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->skeleton())) return false;
  return true;
}

void Skeleton::Swap(Skeleton* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    skeleton_.Swap(&other->skeleton_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Skeleton::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Skeleton_descriptor_;
  metadata.reflection = Skeleton_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SkeletonRaw::kPerceptFieldNumber;
const int SkeletonRaw::kSkeletonFieldNumber;
#endif  // !_MSC_VER

SkeletonRaw::SkeletonRaw()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.SkeletonRaw)
}

void SkeletonRaw::InitAsDefaultInstance() {
  percept_ = const_cast< ::CommonProto::ObstacleRaw*>(&::CommonProto::ObstacleRaw::default_instance());
}

SkeletonRaw::SkeletonRaw(const SkeletonRaw& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.SkeletonRaw)
}

void SkeletonRaw::SharedCtor() {
  _cached_size_ = 0;
  percept_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SkeletonRaw::~SkeletonRaw() {
  // @@protoc_insertion_point(destructor:CommonProto.SkeletonRaw)
  SharedDtor();
}

void SkeletonRaw::SharedDtor() {
  if (this != default_instance_) {
    delete percept_;
  }
}

void SkeletonRaw::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SkeletonRaw::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SkeletonRaw_descriptor_;
}

const SkeletonRaw& SkeletonRaw::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

SkeletonRaw* SkeletonRaw::default_instance_ = NULL;

SkeletonRaw* SkeletonRaw::New() const {
  return new SkeletonRaw;
}

void SkeletonRaw::Clear() {
  if (has_percept()) {
    if (percept_ != NULL) percept_->::CommonProto::ObstacleRaw::Clear();
  }
  skeleton_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SkeletonRaw::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.SkeletonRaw)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .CommonProto.ObstacleRaw percept = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_percept()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_skeleton;
        break;
      }

      // repeated .CommonProto.SkeletonPoint skeleton = 2;
      case 2: {
        if (tag == 18) {
         parse_skeleton:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_skeleton()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_skeleton;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.SkeletonRaw)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.SkeletonRaw)
  return false;
#undef DO_
}

void SkeletonRaw::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.SkeletonRaw)
  // required .CommonProto.ObstacleRaw percept = 1;
  if (has_percept()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->percept(), output);
  }

  // repeated .CommonProto.SkeletonPoint skeleton = 2;
  for (int i = 0; i < this->skeleton_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->skeleton(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.SkeletonRaw)
}

::google::protobuf::uint8* SkeletonRaw::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.SkeletonRaw)
  // required .CommonProto.ObstacleRaw percept = 1;
  if (has_percept()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->percept(), target);
  }

  // repeated .CommonProto.SkeletonPoint skeleton = 2;
  for (int i = 0; i < this->skeleton_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->skeleton(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.SkeletonRaw)
  return target;
}

int SkeletonRaw::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .CommonProto.ObstacleRaw percept = 1;
    if (has_percept()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->percept());
    }

  }
  // repeated .CommonProto.SkeletonPoint skeleton = 2;
  total_size += 1 * this->skeleton_size();
  for (int i = 0; i < this->skeleton_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->skeleton(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SkeletonRaw::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SkeletonRaw* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SkeletonRaw*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SkeletonRaw::MergeFrom(const SkeletonRaw& from) {
  GOOGLE_CHECK_NE(&from, this);
  skeleton_.MergeFrom(from.skeleton_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_percept()) {
      mutable_percept()->::CommonProto::ObstacleRaw::MergeFrom(from.percept());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SkeletonRaw::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SkeletonRaw::CopyFrom(const SkeletonRaw& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SkeletonRaw::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_percept()) {
    if (!this->percept().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->skeleton())) return false;
  return true;
}

void SkeletonRaw::Swap(SkeletonRaw* other) {
  if (other != this) {
    std::swap(percept_, other->percept_);
    skeleton_.Swap(&other->skeleton_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SkeletonRaw::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SkeletonRaw_descriptor_;
  metadata.reflection = SkeletonRaw_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SkeletonRaws::kCamIdFieldNumber;
const int SkeletonRaws::kSkeletonRawFieldNumber;
#endif  // !_MSC_VER

SkeletonRaws::SkeletonRaws()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.SkeletonRaws)
}

void SkeletonRaws::InitAsDefaultInstance() {
}

SkeletonRaws::SkeletonRaws(const SkeletonRaws& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.SkeletonRaws)
}

void SkeletonRaws::SharedCtor() {
  _cached_size_ = 0;
  cam_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SkeletonRaws::~SkeletonRaws() {
  // @@protoc_insertion_point(destructor:CommonProto.SkeletonRaws)
  SharedDtor();
}

void SkeletonRaws::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SkeletonRaws::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SkeletonRaws::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SkeletonRaws_descriptor_;
}

const SkeletonRaws& SkeletonRaws::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

SkeletonRaws* SkeletonRaws::default_instance_ = NULL;

SkeletonRaws* SkeletonRaws::New() const {
  return new SkeletonRaws;
}

void SkeletonRaws::Clear() {
  cam_id_ = 0;
  skeleton_raw_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SkeletonRaws::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.SkeletonRaws)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cam_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cam_id_)));
          set_has_cam_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_skeleton_raw;
        break;
      }

      // repeated .CommonProto.SkeletonRaw skeleton_raw = 2;
      case 2: {
        if (tag == 18) {
         parse_skeleton_raw:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_skeleton_raw()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_skeleton_raw;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.SkeletonRaws)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.SkeletonRaws)
  return false;
#undef DO_
}

void SkeletonRaws::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.SkeletonRaws)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->cam_id(), output);
  }

  // repeated .CommonProto.SkeletonRaw skeleton_raw = 2;
  for (int i = 0; i < this->skeleton_raw_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->skeleton_raw(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.SkeletonRaws)
}

::google::protobuf::uint8* SkeletonRaws::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.SkeletonRaws)
  // optional int32 cam_id = 1;
  if (has_cam_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->cam_id(), target);
  }

  // repeated .CommonProto.SkeletonRaw skeleton_raw = 2;
  for (int i = 0; i < this->skeleton_raw_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->skeleton_raw(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.SkeletonRaws)
  return target;
}

int SkeletonRaws::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 cam_id = 1;
    if (has_cam_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cam_id());
    }

  }
  // repeated .CommonProto.SkeletonRaw skeleton_raw = 2;
  total_size += 1 * this->skeleton_raw_size();
  for (int i = 0; i < this->skeleton_raw_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->skeleton_raw(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SkeletonRaws::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SkeletonRaws* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SkeletonRaws*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SkeletonRaws::MergeFrom(const SkeletonRaws& from) {
  GOOGLE_CHECK_NE(&from, this);
  skeleton_raw_.MergeFrom(from.skeleton_raw_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cam_id()) {
      set_cam_id(from.cam_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SkeletonRaws::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SkeletonRaws::CopyFrom(const SkeletonRaws& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SkeletonRaws::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->skeleton_raw())) return false;
  return true;
}

void SkeletonRaws::Swap(SkeletonRaws* other) {
  if (other != this) {
    std::swap(cam_id_, other->cam_id_);
    skeleton_raw_.Swap(&other->skeleton_raw_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SkeletonRaws::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SkeletonRaws_descriptor_;
  metadata.reflection = SkeletonRaws_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CameraMatrix::kMatGnd2ImgFieldNumber;
const int CameraMatrix::kMatImg2GndFieldNumber;
const int CameraMatrix::kMatVcsgnd2ImgFieldNumber;
const int CameraMatrix::kMatImg2VcsgndFieldNumber;
const int CameraMatrix::kMatLocal2ImgFieldNumber;
const int CameraMatrix::kMatImg2LocalFieldNumber;
#endif  // !_MSC_VER

CameraMatrix::CameraMatrix()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.CameraMatrix)
}

void CameraMatrix::InitAsDefaultInstance() {
}

CameraMatrix::CameraMatrix(const CameraMatrix& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.CameraMatrix)
}

void CameraMatrix::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CameraMatrix::~CameraMatrix() {
  // @@protoc_insertion_point(destructor:CommonProto.CameraMatrix)
  SharedDtor();
}

void CameraMatrix::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CameraMatrix::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CameraMatrix::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CameraMatrix_descriptor_;
}

const CameraMatrix& CameraMatrix::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

CameraMatrix* CameraMatrix::default_instance_ = NULL;

CameraMatrix* CameraMatrix::New() const {
  return new CameraMatrix;
}

void CameraMatrix::Clear() {
  mat_gnd2img_.Clear();
  mat_img2gnd_.Clear();
  mat_vcsgnd2img_.Clear();
  mat_img2vcsgnd_.Clear();
  mat_local2img_.Clear();
  mat_img2local_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CameraMatrix::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.CameraMatrix)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float mat_gnd2img = 1;
      case 1: {
        if (tag == 13) {
         parse_mat_gnd2img:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_mat_gnd2img())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_gnd2img())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(13)) goto parse_mat_gnd2img;
        if (input->ExpectTag(21)) goto parse_mat_img2gnd;
        break;
      }

      // repeated float mat_img2gnd = 2;
      case 2: {
        if (tag == 21) {
         parse_mat_img2gnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_mat_img2gnd())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_img2gnd())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_mat_img2gnd;
        if (input->ExpectTag(29)) goto parse_mat_vcsgnd2img;
        break;
      }

      // repeated float mat_vcsgnd2img = 3;
      case 3: {
        if (tag == 29) {
         parse_mat_vcsgnd2img:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 29, input, this->mutable_mat_vcsgnd2img())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_vcsgnd2img())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_mat_vcsgnd2img;
        if (input->ExpectTag(37)) goto parse_mat_img2vcsgnd;
        break;
      }

      // repeated float mat_img2vcsgnd = 4;
      case 4: {
        if (tag == 37) {
         parse_mat_img2vcsgnd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_mat_img2vcsgnd())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_img2vcsgnd())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_mat_img2vcsgnd;
        if (input->ExpectTag(45)) goto parse_mat_local2img;
        break;
      }

      // repeated float mat_local2img = 5;
      case 5: {
        if (tag == 45) {
         parse_mat_local2img:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 45, input, this->mutable_mat_local2img())));
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_local2img())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_mat_local2img;
        if (input->ExpectTag(53)) goto parse_mat_img2local;
        break;
      }

      // repeated float mat_img2local = 6;
      case 6: {
        if (tag == 53) {
         parse_mat_img2local:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 53, input, this->mutable_mat_img2local())));
        } else if (tag == 50) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_mat_img2local())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_mat_img2local;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.CameraMatrix)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.CameraMatrix)
  return false;
#undef DO_
}

void CameraMatrix::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.CameraMatrix)
  // repeated float mat_gnd2img = 1;
  for (int i = 0; i < this->mat_gnd2img_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->mat_gnd2img(i), output);
  }

  // repeated float mat_img2gnd = 2;
  for (int i = 0; i < this->mat_img2gnd_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->mat_img2gnd(i), output);
  }

  // repeated float mat_vcsgnd2img = 3;
  for (int i = 0; i < this->mat_vcsgnd2img_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      3, this->mat_vcsgnd2img(i), output);
  }

  // repeated float mat_img2vcsgnd = 4;
  for (int i = 0; i < this->mat_img2vcsgnd_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->mat_img2vcsgnd(i), output);
  }

  // repeated float mat_local2img = 5;
  for (int i = 0; i < this->mat_local2img_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      5, this->mat_local2img(i), output);
  }

  // repeated float mat_img2local = 6;
  for (int i = 0; i < this->mat_img2local_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      6, this->mat_img2local(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.CameraMatrix)
}

::google::protobuf::uint8* CameraMatrix::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.CameraMatrix)
  // repeated float mat_gnd2img = 1;
  for (int i = 0; i < this->mat_gnd2img_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(1, this->mat_gnd2img(i), target);
  }

  // repeated float mat_img2gnd = 2;
  for (int i = 0; i < this->mat_img2gnd_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(2, this->mat_img2gnd(i), target);
  }

  // repeated float mat_vcsgnd2img = 3;
  for (int i = 0; i < this->mat_vcsgnd2img_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(3, this->mat_vcsgnd2img(i), target);
  }

  // repeated float mat_img2vcsgnd = 4;
  for (int i = 0; i < this->mat_img2vcsgnd_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(4, this->mat_img2vcsgnd(i), target);
  }

  // repeated float mat_local2img = 5;
  for (int i = 0; i < this->mat_local2img_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(5, this->mat_local2img(i), target);
  }

  // repeated float mat_img2local = 6;
  for (int i = 0; i < this->mat_img2local_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(6, this->mat_img2local(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.CameraMatrix)
  return target;
}

int CameraMatrix::ByteSize() const {
  int total_size = 0;

  // repeated float mat_gnd2img = 1;
  {
    int data_size = 0;
    data_size = 4 * this->mat_gnd2img_size();
    total_size += 1 * this->mat_gnd2img_size() + data_size;
  }

  // repeated float mat_img2gnd = 2;
  {
    int data_size = 0;
    data_size = 4 * this->mat_img2gnd_size();
    total_size += 1 * this->mat_img2gnd_size() + data_size;
  }

  // repeated float mat_vcsgnd2img = 3;
  {
    int data_size = 0;
    data_size = 4 * this->mat_vcsgnd2img_size();
    total_size += 1 * this->mat_vcsgnd2img_size() + data_size;
  }

  // repeated float mat_img2vcsgnd = 4;
  {
    int data_size = 0;
    data_size = 4 * this->mat_img2vcsgnd_size();
    total_size += 1 * this->mat_img2vcsgnd_size() + data_size;
  }

  // repeated float mat_local2img = 5;
  {
    int data_size = 0;
    data_size = 4 * this->mat_local2img_size();
    total_size += 1 * this->mat_local2img_size() + data_size;
  }

  // repeated float mat_img2local = 6;
  {
    int data_size = 0;
    data_size = 4 * this->mat_img2local_size();
    total_size += 1 * this->mat_img2local_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CameraMatrix::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CameraMatrix* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CameraMatrix*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CameraMatrix::MergeFrom(const CameraMatrix& from) {
  GOOGLE_CHECK_NE(&from, this);
  mat_gnd2img_.MergeFrom(from.mat_gnd2img_);
  mat_img2gnd_.MergeFrom(from.mat_img2gnd_);
  mat_vcsgnd2img_.MergeFrom(from.mat_vcsgnd2img_);
  mat_img2vcsgnd_.MergeFrom(from.mat_img2vcsgnd_);
  mat_local2img_.MergeFrom(from.mat_local2img_);
  mat_img2local_.MergeFrom(from.mat_img2local_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CameraMatrix::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraMatrix::CopyFrom(const CameraMatrix& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraMatrix::IsInitialized() const {

  return true;
}

void CameraMatrix::Swap(CameraMatrix* other) {
  if (other != this) {
    mat_gnd2img_.Swap(&other->mat_gnd2img_);
    mat_img2gnd_.Swap(&other->mat_img2gnd_);
    mat_vcsgnd2img_.Swap(&other->mat_vcsgnd2img_);
    mat_img2vcsgnd_.Swap(&other->mat_img2vcsgnd_);
    mat_local2img_.Swap(&other->mat_local2img_);
    mat_img2local_.Swap(&other->mat_img2local_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CameraMatrix::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CameraMatrix_descriptor_;
  metadata.reflection = CameraMatrix_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DistortParam::kParamFieldNumber;
#endif  // !_MSC_VER

DistortParam::DistortParam()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.DistortParam)
}

void DistortParam::InitAsDefaultInstance() {
}

DistortParam::DistortParam(const DistortParam& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.DistortParam)
}

void DistortParam::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DistortParam::~DistortParam() {
  // @@protoc_insertion_point(destructor:CommonProto.DistortParam)
  SharedDtor();
}

void DistortParam::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DistortParam::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DistortParam::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DistortParam_descriptor_;
}

const DistortParam& DistortParam::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

DistortParam* DistortParam::default_instance_ = NULL;

DistortParam* DistortParam::New() const {
  return new DistortParam;
}

void DistortParam::Clear() {
  param_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DistortParam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.DistortParam)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float param = 1;
      case 1: {
        if (tag == 13) {
         parse_param:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_param())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_param())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(13)) goto parse_param;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.DistortParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.DistortParam)
  return false;
#undef DO_
}

void DistortParam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.DistortParam)
  // repeated float param = 1;
  for (int i = 0; i < this->param_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->param(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.DistortParam)
}

::google::protobuf::uint8* DistortParam::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.DistortParam)
  // repeated float param = 1;
  for (int i = 0; i < this->param_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(1, this->param(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.DistortParam)
  return target;
}

int DistortParam::ByteSize() const {
  int total_size = 0;

  // repeated float param = 1;
  {
    int data_size = 0;
    data_size = 4 * this->param_size();
    total_size += 1 * this->param_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DistortParam::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DistortParam* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DistortParam*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DistortParam::MergeFrom(const DistortParam& from) {
  GOOGLE_CHECK_NE(&from, this);
  param_.MergeFrom(from.param_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DistortParam::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DistortParam::CopyFrom(const DistortParam& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DistortParam::IsInitialized() const {

  return true;
}

void DistortParam::Swap(DistortParam* other) {
  if (other != this) {
    param_.Swap(&other->param_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DistortParam::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DistortParam_descriptor_;
  metadata.reflection = DistortParam_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VCSParam::kRotationFieldNumber;
const int VCSParam::kTranslationFieldNumber;
#endif  // !_MSC_VER

VCSParam::VCSParam()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.VCSParam)
}

void VCSParam::InitAsDefaultInstance() {
}

VCSParam::VCSParam(const VCSParam& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.VCSParam)
}

void VCSParam::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VCSParam::~VCSParam() {
  // @@protoc_insertion_point(destructor:CommonProto.VCSParam)
  SharedDtor();
}

void VCSParam::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VCSParam::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VCSParam::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VCSParam_descriptor_;
}

const VCSParam& VCSParam::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

VCSParam* VCSParam::default_instance_ = NULL;

VCSParam* VCSParam::New() const {
  return new VCSParam;
}

void VCSParam::Clear() {
  rotation_.Clear();
  translation_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VCSParam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.VCSParam)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float rotation = 1;
      case 1: {
        if (tag == 13) {
         parse_rotation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_rotation())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_rotation())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(13)) goto parse_rotation;
        if (input->ExpectTag(21)) goto parse_translation;
        break;
      }

      // repeated float translation = 2;
      case 2: {
        if (tag == 21) {
         parse_translation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_translation())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_translation())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_translation;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.VCSParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.VCSParam)
  return false;
#undef DO_
}

void VCSParam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.VCSParam)
  // repeated float rotation = 1;
  for (int i = 0; i < this->rotation_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->rotation(i), output);
  }

  // repeated float translation = 2;
  for (int i = 0; i < this->translation_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->translation(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.VCSParam)
}

::google::protobuf::uint8* VCSParam::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.VCSParam)
  // repeated float rotation = 1;
  for (int i = 0; i < this->rotation_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(1, this->rotation(i), target);
  }

  // repeated float translation = 2;
  for (int i = 0; i < this->translation_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(2, this->translation(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.VCSParam)
  return target;
}

int VCSParam::ByteSize() const {
  int total_size = 0;

  // repeated float rotation = 1;
  {
    int data_size = 0;
    data_size = 4 * this->rotation_size();
    total_size += 1 * this->rotation_size() + data_size;
  }

  // repeated float translation = 2;
  {
    int data_size = 0;
    data_size = 4 * this->translation_size();
    total_size += 1 * this->translation_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VCSParam::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VCSParam* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VCSParam*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VCSParam::MergeFrom(const VCSParam& from) {
  GOOGLE_CHECK_NE(&from, this);
  rotation_.MergeFrom(from.rotation_);
  translation_.MergeFrom(from.translation_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VCSParam::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VCSParam::CopyFrom(const VCSParam& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VCSParam::IsInitialized() const {

  return true;
}

void VCSParam::Swap(VCSParam* other) {
  if (other != this) {
    rotation_.Swap(&other->rotation_);
    translation_.Swap(&other->translation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VCSParam::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VCSParam_descriptor_;
  metadata.reflection = VCSParam_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CameraParam::kFocalUFieldNumber;
const int CameraParam::kFocalVFieldNumber;
const int CameraParam::kCenterUFieldNumber;
const int CameraParam::kCenterVFieldNumber;
const int CameraParam::kCameraXFieldNumber;
const int CameraParam::kCameraYFieldNumber;
const int CameraParam::kCameraZFieldNumber;
const int CameraParam::kPitchFieldNumber;
const int CameraParam::kYawFieldNumber;
const int CameraParam::kRollFieldNumber;
const int CameraParam::kTypeFieldNumber;
const int CameraParam::kFovFieldNumber;
const int CameraParam::kVersionFieldNumber;
const int CameraParam::kCaliStatusFieldNumber;
const int CameraParam::kDistortFieldNumber;
const int CameraParam::kVcsFieldNumber;
const int CameraParam::kMatFieldNumber;
const int CameraParam::kVendorFieldNumber;
#endif  // !_MSC_VER

CameraParam::CameraParam()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.CameraParam)
}

void CameraParam::InitAsDefaultInstance() {
  distort_ = const_cast< ::CommonProto::DistortParam*>(&::CommonProto::DistortParam::default_instance());
  vcs_ = const_cast< ::CommonProto::VCSParam*>(&::CommonProto::VCSParam::default_instance());
  mat_ = const_cast< ::CommonProto::CameraMatrix*>(&::CommonProto::CameraMatrix::default_instance());
}

CameraParam::CameraParam(const CameraParam& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.CameraParam)
}

void CameraParam::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  focal_u_ = 0;
  focal_v_ = 0;
  center_u_ = 0;
  center_v_ = 0;
  camera_x_ = 0;
  camera_y_ = 0;
  camera_z_ = 0;
  pitch_ = 0;
  yaw_ = 0;
  roll_ = 0;
  type_ = 0;
  fov_ = 0;
  version_ = 0;
  cali_status_ = 0;
  distort_ = NULL;
  vcs_ = NULL;
  mat_ = NULL;
  vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CameraParam::~CameraParam() {
  // @@protoc_insertion_point(destructor:CommonProto.CameraParam)
  SharedDtor();
}

void CameraParam::SharedDtor() {
  if (vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendor_;
  }
  if (this != default_instance_) {
    delete distort_;
    delete vcs_;
    delete mat_;
  }
}

void CameraParam::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CameraParam::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CameraParam_descriptor_;
}

const CameraParam& CameraParam::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

CameraParam* CameraParam::default_instance_ = NULL;

CameraParam* CameraParam::New() const {
  return new CameraParam;
}

void CameraParam::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CameraParam*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(focal_u_, pitch_);
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(yaw_, cali_status_);
    if (has_distort()) {
      if (distort_ != NULL) distort_->::CommonProto::DistortParam::Clear();
    }
    if (has_vcs()) {
      if (vcs_ != NULL) vcs_->::CommonProto::VCSParam::Clear();
    }
  }
  if (_has_bits_[16 / 32] & 196608) {
    if (has_mat()) {
      if (mat_ != NULL) mat_->::CommonProto::CameraMatrix::Clear();
    }
    if (has_vendor()) {
      if (vendor_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        vendor_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CameraParam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.CameraParam)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float focal_u = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &focal_u_)));
          set_has_focal_u();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_focal_v;
        break;
      }

      // required float focal_v = 2;
      case 2: {
        if (tag == 21) {
         parse_focal_v:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &focal_v_)));
          set_has_focal_v();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_center_u;
        break;
      }

      // required float center_u = 3;
      case 3: {
        if (tag == 29) {
         parse_center_u:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &center_u_)));
          set_has_center_u();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_center_v;
        break;
      }

      // required float center_v = 4;
      case 4: {
        if (tag == 37) {
         parse_center_v:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &center_v_)));
          set_has_center_v();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_camera_x;
        break;
      }

      // required float camera_x = 5;
      case 5: {
        if (tag == 45) {
         parse_camera_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &camera_x_)));
          set_has_camera_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_camera_y;
        break;
      }

      // required float camera_y = 6;
      case 6: {
        if (tag == 53) {
         parse_camera_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &camera_y_)));
          set_has_camera_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_camera_z;
        break;
      }

      // required float camera_z = 7;
      case 7: {
        if (tag == 61) {
         parse_camera_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &camera_z_)));
          set_has_camera_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_pitch;
        break;
      }

      // required float pitch = 8;
      case 8: {
        if (tag == 69) {
         parse_pitch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pitch_)));
          set_has_pitch();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_yaw;
        break;
      }

      // required float yaw = 9;
      case 9: {
        if (tag == 77) {
         parse_yaw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_)));
          set_has_yaw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_roll;
        break;
      }

      // required float roll = 10;
      case 10: {
        if (tag == 85) {
         parse_roll:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &roll_)));
          set_has_roll();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_type;
        break;
      }

      // optional int32 type = 11 [default = 0];
      case 11: {
        if (tag == 88) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(101)) goto parse_fov;
        break;
      }

      // optional float fov = 12;
      case 12: {
        if (tag == 101) {
         parse_fov:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fov_)));
          set_has_fov();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_version;
        break;
      }

      // optional int32 version = 13 [default = 0];
      case 13: {
        if (tag == 104) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_cali_status;
        break;
      }

      // optional .CommonProto.CalibrationStatus cali_status = 14;
      case 14: {
        if (tag == 112) {
         parse_cali_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CommonProto::CalibrationStatus_IsValid(value)) {
            set_cali_status(static_cast< ::CommonProto::CalibrationStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(14, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_distort;
        break;
      }

      // optional .CommonProto.DistortParam distort = 20;
      case 20: {
        if (tag == 162) {
         parse_distort:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_distort()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_vcs;
        break;
      }

      // optional .CommonProto.VCSParam vcs = 21;
      case 21: {
        if (tag == 170) {
         parse_vcs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vcs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(242)) goto parse_mat;
        break;
      }

      // optional .CommonProto.CameraMatrix mat = 30;
      case 30: {
        if (tag == 242) {
         parse_mat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mat()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(402)) goto parse_vendor;
        break;
      }

      // optional string vendor = 50;
      case 50: {
        if (tag == 402) {
         parse_vendor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vendor()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->vendor().data(), this->vendor().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "vendor");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.CameraParam)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.CameraParam)
  return false;
#undef DO_
}

void CameraParam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.CameraParam)
  // required float focal_u = 1;
  if (has_focal_u()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->focal_u(), output);
  }

  // required float focal_v = 2;
  if (has_focal_v()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->focal_v(), output);
  }

  // required float center_u = 3;
  if (has_center_u()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->center_u(), output);
  }

  // required float center_v = 4;
  if (has_center_v()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->center_v(), output);
  }

  // required float camera_x = 5;
  if (has_camera_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->camera_x(), output);
  }

  // required float camera_y = 6;
  if (has_camera_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->camera_y(), output);
  }

  // required float camera_z = 7;
  if (has_camera_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->camera_z(), output);
  }

  // required float pitch = 8;
  if (has_pitch()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->pitch(), output);
  }

  // required float yaw = 9;
  if (has_yaw()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->yaw(), output);
  }

  // required float roll = 10;
  if (has_roll()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->roll(), output);
  }

  // optional int32 type = 11 [default = 0];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->type(), output);
  }

  // optional float fov = 12;
  if (has_fov()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->fov(), output);
  }

  // optional int32 version = 13 [default = 0];
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->version(), output);
  }

  // optional .CommonProto.CalibrationStatus cali_status = 14;
  if (has_cali_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      14, this->cali_status(), output);
  }

  // optional .CommonProto.DistortParam distort = 20;
  if (has_distort()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, this->distort(), output);
  }

  // optional .CommonProto.VCSParam vcs = 21;
  if (has_vcs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, this->vcs(), output);
  }

  // optional .CommonProto.CameraMatrix mat = 30;
  if (has_mat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      30, this->mat(), output);
  }

  // optional string vendor = 50;
  if (has_vendor()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vendor");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      50, this->vendor(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.CameraParam)
}

::google::protobuf::uint8* CameraParam::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.CameraParam)
  // required float focal_u = 1;
  if (has_focal_u()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->focal_u(), target);
  }

  // required float focal_v = 2;
  if (has_focal_v()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->focal_v(), target);
  }

  // required float center_u = 3;
  if (has_center_u()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->center_u(), target);
  }

  // required float center_v = 4;
  if (has_center_v()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->center_v(), target);
  }

  // required float camera_x = 5;
  if (has_camera_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->camera_x(), target);
  }

  // required float camera_y = 6;
  if (has_camera_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->camera_y(), target);
  }

  // required float camera_z = 7;
  if (has_camera_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->camera_z(), target);
  }

  // required float pitch = 8;
  if (has_pitch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->pitch(), target);
  }

  // required float yaw = 9;
  if (has_yaw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->yaw(), target);
  }

  // required float roll = 10;
  if (has_roll()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->roll(), target);
  }

  // optional int32 type = 11 [default = 0];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->type(), target);
  }

  // optional float fov = 12;
  if (has_fov()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->fov(), target);
  }

  // optional int32 version = 13 [default = 0];
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->version(), target);
  }

  // optional .CommonProto.CalibrationStatus cali_status = 14;
  if (has_cali_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      14, this->cali_status(), target);
  }

  // optional .CommonProto.DistortParam distort = 20;
  if (has_distort()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, this->distort(), target);
  }

  // optional .CommonProto.VCSParam vcs = 21;
  if (has_vcs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, this->vcs(), target);
  }

  // optional .CommonProto.CameraMatrix mat = 30;
  if (has_mat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        30, this->mat(), target);
  }

  // optional string vendor = 50;
  if (has_vendor()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vendor");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        50, this->vendor(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.CameraParam)
  return target;
}

int CameraParam::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float focal_u = 1;
    if (has_focal_u()) {
      total_size += 1 + 4;
    }

    // required float focal_v = 2;
    if (has_focal_v()) {
      total_size += 1 + 4;
    }

    // required float center_u = 3;
    if (has_center_u()) {
      total_size += 1 + 4;
    }

    // required float center_v = 4;
    if (has_center_v()) {
      total_size += 1 + 4;
    }

    // required float camera_x = 5;
    if (has_camera_x()) {
      total_size += 1 + 4;
    }

    // required float camera_y = 6;
    if (has_camera_y()) {
      total_size += 1 + 4;
    }

    // required float camera_z = 7;
    if (has_camera_z()) {
      total_size += 1 + 4;
    }

    // required float pitch = 8;
    if (has_pitch()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required float yaw = 9;
    if (has_yaw()) {
      total_size += 1 + 4;
    }

    // required float roll = 10;
    if (has_roll()) {
      total_size += 1 + 4;
    }

    // optional int32 type = 11 [default = 0];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional float fov = 12;
    if (has_fov()) {
      total_size += 1 + 4;
    }

    // optional int32 version = 13 [default = 0];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }

    // optional .CommonProto.CalibrationStatus cali_status = 14;
    if (has_cali_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cali_status());
    }

    // optional .CommonProto.DistortParam distort = 20;
    if (has_distort()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->distort());
    }

    // optional .CommonProto.VCSParam vcs = 21;
    if (has_vcs()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vcs());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional .CommonProto.CameraMatrix mat = 30;
    if (has_mat()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mat());
    }

    // optional string vendor = 50;
    if (has_vendor()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vendor());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CameraParam::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CameraParam* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CameraParam*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CameraParam::MergeFrom(const CameraParam& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_focal_u()) {
      set_focal_u(from.focal_u());
    }
    if (from.has_focal_v()) {
      set_focal_v(from.focal_v());
    }
    if (from.has_center_u()) {
      set_center_u(from.center_u());
    }
    if (from.has_center_v()) {
      set_center_v(from.center_v());
    }
    if (from.has_camera_x()) {
      set_camera_x(from.camera_x());
    }
    if (from.has_camera_y()) {
      set_camera_y(from.camera_y());
    }
    if (from.has_camera_z()) {
      set_camera_z(from.camera_z());
    }
    if (from.has_pitch()) {
      set_pitch(from.pitch());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_yaw()) {
      set_yaw(from.yaw());
    }
    if (from.has_roll()) {
      set_roll(from.roll());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_fov()) {
      set_fov(from.fov());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_cali_status()) {
      set_cali_status(from.cali_status());
    }
    if (from.has_distort()) {
      mutable_distort()->::CommonProto::DistortParam::MergeFrom(from.distort());
    }
    if (from.has_vcs()) {
      mutable_vcs()->::CommonProto::VCSParam::MergeFrom(from.vcs());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_mat()) {
      mutable_mat()->::CommonProto::CameraMatrix::MergeFrom(from.mat());
    }
    if (from.has_vendor()) {
      set_vendor(from.vendor());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CameraParam::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraParam::CopyFrom(const CameraParam& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraParam::IsInitialized() const {
  if ((_has_bits_[0] & 0x000003ff) != 0x000003ff) return false;

  return true;
}

void CameraParam::Swap(CameraParam* other) {
  if (other != this) {
    std::swap(focal_u_, other->focal_u_);
    std::swap(focal_v_, other->focal_v_);
    std::swap(center_u_, other->center_u_);
    std::swap(center_v_, other->center_v_);
    std::swap(camera_x_, other->camera_x_);
    std::swap(camera_y_, other->camera_y_);
    std::swap(camera_z_, other->camera_z_);
    std::swap(pitch_, other->pitch_);
    std::swap(yaw_, other->yaw_);
    std::swap(roll_, other->roll_);
    std::swap(type_, other->type_);
    std::swap(fov_, other->fov_);
    std::swap(version_, other->version_);
    std::swap(cali_status_, other->cali_status_);
    std::swap(distort_, other->distort_);
    std::swap(vcs_, other->vcs_);
    std::swap(mat_, other->mat_);
    std::swap(vendor_, other->vendor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CameraParam::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CameraParam_descriptor_;
  metadata.reflection = CameraParam_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MotionFrame::kSpeedFieldNumber;
const int MotionFrame::kAccFieldNumber;
const int MotionFrame::kYawRateFieldNumber;
const int MotionFrame::kTimeStampFieldNumber;
const int MotionFrame::kTurningRadiusFieldNumber;
const int MotionFrame::kIsStableFieldNumber;
#endif  // !_MSC_VER

MotionFrame::MotionFrame()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.MotionFrame)
}

void MotionFrame::InitAsDefaultInstance() {
}

MotionFrame::MotionFrame(const MotionFrame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.MotionFrame)
}

void MotionFrame::SharedCtor() {
  _cached_size_ = 0;
  speed_ = 0;
  acc_ = 0;
  yaw_rate_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  turning_radius_ = 0;
  is_stable_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MotionFrame::~MotionFrame() {
  // @@protoc_insertion_point(destructor:CommonProto.MotionFrame)
  SharedDtor();
}

void MotionFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MotionFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MotionFrame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MotionFrame_descriptor_;
}

const MotionFrame& MotionFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

MotionFrame* MotionFrame::default_instance_ = NULL;

MotionFrame* MotionFrame::New() const {
  return new MotionFrame;
}

void MotionFrame::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MotionFrame*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(speed_, is_stable_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MotionFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.MotionFrame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float speed = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_acc;
        break;
      }

      // optional float acc = 2;
      case 2: {
        if (tag == 21) {
         parse_acc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc_)));
          set_has_acc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_yaw_rate;
        break;
      }

      // required float yaw_rate = 3;
      case 3: {
        if (tag == 29) {
         parse_yaw_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_rate_)));
          set_has_yaw_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_time_stamp;
        break;
      }

      // required int64 time_stamp = 4;
      case 4: {
        if (tag == 32) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_turning_radius;
        break;
      }

      // optional float turning_radius = 5;
      case 5: {
        if (tag == 45) {
         parse_turning_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &turning_radius_)));
          set_has_turning_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_is_stable;
        break;
      }

      // optional bool is_stable = 6;
      case 6: {
        if (tag == 48) {
         parse_is_stable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_stable_)));
          set_has_is_stable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.MotionFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.MotionFrame)
  return false;
#undef DO_
}

void MotionFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.MotionFrame)
  // required float speed = 1;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->speed(), output);
  }

  // optional float acc = 2;
  if (has_acc()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->acc(), output);
  }

  // required float yaw_rate = 3;
  if (has_yaw_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->yaw_rate(), output);
  }

  // required int64 time_stamp = 4;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->time_stamp(), output);
  }

  // optional float turning_radius = 5;
  if (has_turning_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->turning_radius(), output);
  }

  // optional bool is_stable = 6;
  if (has_is_stable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->is_stable(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.MotionFrame)
}

::google::protobuf::uint8* MotionFrame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.MotionFrame)
  // required float speed = 1;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->speed(), target);
  }

  // optional float acc = 2;
  if (has_acc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->acc(), target);
  }

  // required float yaw_rate = 3;
  if (has_yaw_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->yaw_rate(), target);
  }

  // required int64 time_stamp = 4;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->time_stamp(), target);
  }

  // optional float turning_radius = 5;
  if (has_turning_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->turning_radius(), target);
  }

  // optional bool is_stable = 6;
  if (has_is_stable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->is_stable(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.MotionFrame)
  return target;
}

int MotionFrame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float speed = 1;
    if (has_speed()) {
      total_size += 1 + 4;
    }

    // optional float acc = 2;
    if (has_acc()) {
      total_size += 1 + 4;
    }

    // required float yaw_rate = 3;
    if (has_yaw_rate()) {
      total_size += 1 + 4;
    }

    // required int64 time_stamp = 4;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional float turning_radius = 5;
    if (has_turning_radius()) {
      total_size += 1 + 4;
    }

    // optional bool is_stable = 6;
    if (has_is_stable()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MotionFrame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MotionFrame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MotionFrame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MotionFrame::MergeFrom(const MotionFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_acc()) {
      set_acc(from.acc());
    }
    if (from.has_yaw_rate()) {
      set_yaw_rate(from.yaw_rate());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_turning_radius()) {
      set_turning_radius(from.turning_radius());
    }
    if (from.has_is_stable()) {
      set_is_stable(from.is_stable());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MotionFrame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionFrame::CopyFrom(const MotionFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  return true;
}

void MotionFrame::Swap(MotionFrame* other) {
  if (other != this) {
    std::swap(speed_, other->speed_);
    std::swap(acc_, other->acc_);
    std::swap(yaw_rate_, other->yaw_rate_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(turning_radius_, other->turning_radius_);
    std::swap(is_stable_, other->is_stable_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MotionFrame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MotionFrame_descriptor_;
  metadata.reflection = MotionFrame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OdometryFrame::kXFieldNumber;
const int OdometryFrame::kYFieldNumber;
const int OdometryFrame::kYawFieldNumber;
const int OdometryFrame::kSpeedFieldNumber;
const int OdometryFrame::kYawRateFieldNumber;
const int OdometryFrame::kTimeStampFieldNumber;
#endif  // !_MSC_VER

OdometryFrame::OdometryFrame()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.OdometryFrame)
}

void OdometryFrame::InitAsDefaultInstance() {
}

OdometryFrame::OdometryFrame(const OdometryFrame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.OdometryFrame)
}

void OdometryFrame::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  yaw_ = 0;
  speed_ = 0;
  yaw_rate_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OdometryFrame::~OdometryFrame() {
  // @@protoc_insertion_point(destructor:CommonProto.OdometryFrame)
  SharedDtor();
}

void OdometryFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OdometryFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OdometryFrame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OdometryFrame_descriptor_;
}

const OdometryFrame& OdometryFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

OdometryFrame* OdometryFrame::default_instance_ = NULL;

OdometryFrame* OdometryFrame::New() const {
  return new OdometryFrame;
}

void OdometryFrame::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OdometryFrame*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(x_, yaw_rate_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OdometryFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.OdometryFrame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_yaw;
        break;
      }

      // required float yaw = 3;
      case 3: {
        if (tag == 29) {
         parse_yaw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_)));
          set_has_yaw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_speed;
        break;
      }

      // required float speed = 4;
      case 4: {
        if (tag == 37) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_yaw_rate;
        break;
      }

      // required float yaw_rate = 5;
      case 5: {
        if (tag == 45) {
         parse_yaw_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_rate_)));
          set_has_yaw_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_time_stamp;
        break;
      }

      // required int64 time_stamp = 6;
      case 6: {
        if (tag == 48) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.OdometryFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.OdometryFrame)
  return false;
#undef DO_
}

void OdometryFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.OdometryFrame)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float yaw = 3;
  if (has_yaw()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->yaw(), output);
  }

  // required float speed = 4;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->speed(), output);
  }

  // required float yaw_rate = 5;
  if (has_yaw_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->yaw_rate(), output);
  }

  // required int64 time_stamp = 6;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.OdometryFrame)
}

::google::protobuf::uint8* OdometryFrame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.OdometryFrame)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float yaw = 3;
  if (has_yaw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->yaw(), target);
  }

  // required float speed = 4;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->speed(), target);
  }

  // required float yaw_rate = 5;
  if (has_yaw_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->yaw_rate(), target);
  }

  // required int64 time_stamp = 6;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.OdometryFrame)
  return target;
}

int OdometryFrame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float yaw = 3;
    if (has_yaw()) {
      total_size += 1 + 4;
    }

    // required float speed = 4;
    if (has_speed()) {
      total_size += 1 + 4;
    }

    // required float yaw_rate = 5;
    if (has_yaw_rate()) {
      total_size += 1 + 4;
    }

    // required int64 time_stamp = 6;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OdometryFrame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OdometryFrame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OdometryFrame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OdometryFrame::MergeFrom(const OdometryFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_yaw()) {
      set_yaw(from.yaw());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_yaw_rate()) {
      set_yaw_rate(from.yaw_rate());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OdometryFrame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OdometryFrame::CopyFrom(const OdometryFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OdometryFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void OdometryFrame::Swap(OdometryFrame* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(yaw_, other->yaw_);
    std::swap(speed_, other->speed_);
    std::swap(yaw_rate_, other->yaw_rate_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OdometryFrame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OdometryFrame_descriptor_;
  metadata.reflection = OdometryFrame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SerializedData::kTypeFieldNumber;
const int SerializedData::kProtoFieldNumber;
const int SerializedData::kChannelFieldNumber;
const int SerializedData::kWithDataFieldFieldNumber;
#endif  // !_MSC_VER

SerializedData::SerializedData()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.SerializedData)
}

void SerializedData::InitAsDefaultInstance() {
}

SerializedData::SerializedData(const SerializedData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.SerializedData)
}

void SerializedData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  channel_ = 0;
  with_data_field_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SerializedData::~SerializedData() {
  // @@protoc_insertion_point(destructor:CommonProto.SerializedData)
  SharedDtor();
}

void SerializedData::SharedDtor() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (proto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete proto_;
  }
  if (this != default_instance_) {
  }
}

void SerializedData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SerializedData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SerializedData_descriptor_;
}

const SerializedData& SerializedData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

SerializedData* SerializedData::default_instance_ = NULL;

SerializedData* SerializedData::New() const {
  return new SerializedData;
}

void SerializedData::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        type_->clear();
      }
    }
    if (has_proto()) {
      if (proto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        proto_->clear();
      }
    }
    channel_ = 0;
    with_data_field_ = true;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SerializedData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.SerializedData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_proto;
        break;
      }

      // required bytes proto = 2;
      case 2: {
        if (tag == 18) {
         parse_proto:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_proto()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_channel;
        break;
      }

      // required int32 channel = 4 [default = 0];
      case 4: {
        if (tag == 32) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_with_data_field;
        break;
      }

      // required bool with_data_field = 5 [default = true];
      case 5: {
        if (tag == 40) {
         parse_with_data_field:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &with_data_field_)));
          set_has_with_data_field();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.SerializedData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.SerializedData)
  return false;
#undef DO_
}

void SerializedData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.SerializedData)
  // required string type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->type(), output);
  }

  // required bytes proto = 2;
  if (has_proto()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->proto(), output);
  }

  // required int32 channel = 4 [default = 0];
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->channel(), output);
  }

  // required bool with_data_field = 5 [default = true];
  if (has_with_data_field()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->with_data_field(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.SerializedData)
}

::google::protobuf::uint8* SerializedData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.SerializedData)
  // required string type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->type(), target);
  }

  // required bytes proto = 2;
  if (has_proto()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->proto(), target);
  }

  // required int32 channel = 4 [default = 0];
  if (has_channel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->channel(), target);
  }

  // required bool with_data_field = 5 [default = true];
  if (has_with_data_field()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->with_data_field(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.SerializedData)
  return target;
}

int SerializedData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // required bytes proto = 2;
    if (has_proto()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->proto());
    }

    // required int32 channel = 4 [default = 0];
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel());
    }

    // required bool with_data_field = 5 [default = true];
    if (has_with_data_field()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SerializedData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SerializedData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SerializedData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SerializedData::MergeFrom(const SerializedData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_proto()) {
      set_proto(from.proto());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_with_data_field()) {
      set_with_data_field(from.with_data_field());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SerializedData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SerializedData::CopyFrom(const SerializedData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SerializedData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void SerializedData::Swap(SerializedData* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(proto_, other->proto_);
    std::swap(channel_, other->channel_);
    std::swap(with_data_field_, other->with_data_field_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SerializedData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SerializedData_descriptor_;
  metadata.reflection = SerializedData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DataDescriptor::kTypeFieldNumber;
const int DataDescriptor::kDataFieldNumber;
#endif  // !_MSC_VER

DataDescriptor::DataDescriptor()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.DataDescriptor)
}

void DataDescriptor::InitAsDefaultInstance() {
  data_ = const_cast< ::CommonProto::SerializedData*>(&::CommonProto::SerializedData::default_instance());
}

DataDescriptor::DataDescriptor(const DataDescriptor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.DataDescriptor)
}

void DataDescriptor::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataDescriptor::~DataDescriptor() {
  // @@protoc_insertion_point(destructor:CommonProto.DataDescriptor)
  SharedDtor();
}

void DataDescriptor::SharedDtor() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (this != default_instance_) {
    delete data_;
  }
}

void DataDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataDescriptor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataDescriptor_descriptor_;
}

const DataDescriptor& DataDescriptor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

DataDescriptor* DataDescriptor::default_instance_ = NULL;

DataDescriptor* DataDescriptor::New() const {
  return new DataDescriptor;
}

void DataDescriptor::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        type_->clear();
      }
    }
    if (has_data()) {
      if (data_ != NULL) data_->::CommonProto::SerializedData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.DataDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // optional .CommonProto.SerializedData data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.DataDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.DataDescriptor)
  return false;
#undef DO_
}

void DataDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.DataDescriptor)
  // optional string type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->type(), output);
  }

  // optional .CommonProto.SerializedData data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.DataDescriptor)
}

::google::protobuf::uint8* DataDescriptor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.DataDescriptor)
  // optional string type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->type(), target);
  }

  // optional .CommonProto.SerializedData data = 2;
  if (has_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.DataDescriptor)
  return target;
}

int DataDescriptor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional .CommonProto.SerializedData data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataDescriptor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataDescriptor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataDescriptor::MergeFrom(const DataDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_data()) {
      mutable_data()->::CommonProto::SerializedData::MergeFrom(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataDescriptor::CopyFrom(const DataDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataDescriptor::IsInitialized() const {

  if (has_data()) {
    if (!this->data().IsInitialized()) return false;
  }
  return true;
}

void DataDescriptor::Swap(DataDescriptor* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DataDescriptor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataDescriptor_descriptor_;
  metadata.reflection = DataDescriptor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Color::kBFieldNumber;
const int Color::kGFieldNumber;
const int Color::kRFieldNumber;
#endif  // !_MSC_VER

Color::Color()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.Color)
}

void Color::InitAsDefaultInstance() {
}

Color::Color(const Color& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.Color)
}

void Color::SharedCtor() {
  _cached_size_ = 0;
  b_ = 0u;
  g_ = 0u;
  r_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Color::~Color() {
  // @@protoc_insertion_point(destructor:CommonProto.Color)
  SharedDtor();
}

void Color::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Color::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Color::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Color_descriptor_;
}

const Color& Color::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

Color* Color::default_instance_ = NULL;

Color* Color::New() const {
  return new Color;
}

void Color::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Color*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(b_, r_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Color::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.Color)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 b = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &b_)));
          set_has_b();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_g;
        break;
      }

      // required uint32 g = 2;
      case 2: {
        if (tag == 16) {
         parse_g:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &g_)));
          set_has_g();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_r;
        break;
      }

      // required uint32 r = 3;
      case 3: {
        if (tag == 24) {
         parse_r:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &r_)));
          set_has_r();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.Color)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.Color)
  return false;
#undef DO_
}

void Color::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.Color)
  // required uint32 b = 1;
  if (has_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->b(), output);
  }

  // required uint32 g = 2;
  if (has_g()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->g(), output);
  }

  // required uint32 r = 3;
  if (has_r()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->r(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.Color)
}

::google::protobuf::uint8* Color::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.Color)
  // required uint32 b = 1;
  if (has_b()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->b(), target);
  }

  // required uint32 g = 2;
  if (has_g()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->g(), target);
  }

  // required uint32 r = 3;
  if (has_r()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->r(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.Color)
  return target;
}

int Color::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 b = 1;
    if (has_b()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->b());
    }

    // required uint32 g = 2;
    if (has_g()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->g());
    }

    // required uint32 r = 3;
    if (has_r()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->r());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Color::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Color* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Color*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Color::MergeFrom(const Color& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_b()) {
      set_b(from.b());
    }
    if (from.has_g()) {
      set_g(from.g());
    }
    if (from.has_r()) {
      set_r(from.r());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Color::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Color::CopyFrom(const Color& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Color::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Color::Swap(Color* other) {
  if (other != this) {
    std::swap(b_, other->b_);
    std::swap(g_, other->g_);
    std::swap(r_, other->r_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Color::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Color_descriptor_;
  metadata.reflection = Color_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ParsingSetting::kParsingTypeFieldNumber;
const int ParsingSetting::kParsingChannelsFieldNumber;
const int ParsingSetting::kChannelLabelsFieldNumber;
const int ParsingSetting::kChannelColorsFieldNumber;
const int ParsingSetting::kFreespaceChannelsFieldNumber;
const int ParsingSetting::kBoundspaceChannelsFieldNumber;
#endif  // !_MSC_VER

ParsingSetting::ParsingSetting()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CommonProto.ParsingSetting)
}

void ParsingSetting::InitAsDefaultInstance() {
}

ParsingSetting::ParsingSetting(const ParsingSetting& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CommonProto.ParsingSetting)
}

void ParsingSetting::SharedCtor() {
  _cached_size_ = 0;
  parsing_type_ = 0;
  parsing_channels_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParsingSetting::~ParsingSetting() {
  // @@protoc_insertion_point(destructor:CommonProto.ParsingSetting)
  SharedDtor();
}

void ParsingSetting::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ParsingSetting::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParsingSetting::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ParsingSetting_descriptor_;
}

const ParsingSetting& ParsingSetting::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

ParsingSetting* ParsingSetting::default_instance_ = NULL;

ParsingSetting* ParsingSetting::New() const {
  return new ParsingSetting;
}

void ParsingSetting::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ParsingSetting*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(parsing_type_, parsing_channels_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  channel_labels_.Clear();
  channel_colors_.Clear();
  freespace_channels_.Clear();
  boundspace_channels_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ParsingSetting::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CommonProto.ParsingSetting)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 parsing_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &parsing_type_)));
          set_has_parsing_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_parsing_channels;
        break;
      }

      // required int32 parsing_channels = 2;
      case 2: {
        if (tag == 16) {
         parse_parsing_channels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &parsing_channels_)));
          set_has_parsing_channels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_channel_labels;
        break;
      }

      // repeated uint64 channel_labels = 3;
      case 3: {
        if (tag == 24) {
         parse_channel_labels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24, input, this->mutable_channel_labels())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_channel_labels())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_channel_labels;
        if (input->ExpectTag(34)) goto parse_channel_colors;
        break;
      }

      // repeated .CommonProto.Color channel_colors = 4;
      case 4: {
        if (tag == 34) {
         parse_channel_colors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_channel_colors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_channel_colors;
        if (input->ExpectTag(40)) goto parse_freespace_channels;
        break;
      }

      // repeated int32 freespace_channels = 5;
      case 5: {
        if (tag == 40) {
         parse_freespace_channels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 40, input, this->mutable_freespace_channels())));
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_freespace_channels())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_freespace_channels;
        if (input->ExpectTag(48)) goto parse_boundspace_channels;
        break;
      }

      // repeated int32 boundspace_channels = 6;
      case 6: {
        if (tag == 48) {
         parse_boundspace_channels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 48, input, this->mutable_boundspace_channels())));
        } else if (tag == 50) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_boundspace_channels())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_boundspace_channels;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CommonProto.ParsingSetting)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CommonProto.ParsingSetting)
  return false;
#undef DO_
}

void ParsingSetting::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CommonProto.ParsingSetting)
  // required int32 parsing_type = 1;
  if (has_parsing_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->parsing_type(), output);
  }

  // required int32 parsing_channels = 2;
  if (has_parsing_channels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->parsing_channels(), output);
  }

  // repeated uint64 channel_labels = 3;
  for (int i = 0; i < this->channel_labels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      3, this->channel_labels(i), output);
  }

  // repeated .CommonProto.Color channel_colors = 4;
  for (int i = 0; i < this->channel_colors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->channel_colors(i), output);
  }

  // repeated int32 freespace_channels = 5;
  for (int i = 0; i < this->freespace_channels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      5, this->freespace_channels(i), output);
  }

  // repeated int32 boundspace_channels = 6;
  for (int i = 0; i < this->boundspace_channels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      6, this->boundspace_channels(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CommonProto.ParsingSetting)
}

::google::protobuf::uint8* ParsingSetting::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommonProto.ParsingSetting)
  // required int32 parsing_type = 1;
  if (has_parsing_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->parsing_type(), target);
  }

  // required int32 parsing_channels = 2;
  if (has_parsing_channels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->parsing_channels(), target);
  }

  // repeated uint64 channel_labels = 3;
  for (int i = 0; i < this->channel_labels_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(3, this->channel_labels(i), target);
  }

  // repeated .CommonProto.Color channel_colors = 4;
  for (int i = 0; i < this->channel_colors_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->channel_colors(i), target);
  }

  // repeated int32 freespace_channels = 5;
  for (int i = 0; i < this->freespace_channels_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(5, this->freespace_channels(i), target);
  }

  // repeated int32 boundspace_channels = 6;
  for (int i = 0; i < this->boundspace_channels_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(6, this->boundspace_channels(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommonProto.ParsingSetting)
  return target;
}

int ParsingSetting::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 parsing_type = 1;
    if (has_parsing_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->parsing_type());
    }

    // required int32 parsing_channels = 2;
    if (has_parsing_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->parsing_channels());
    }

  }
  // repeated uint64 channel_labels = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->channel_labels_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->channel_labels(i));
    }
    total_size += 1 * this->channel_labels_size() + data_size;
  }

  // repeated .CommonProto.Color channel_colors = 4;
  total_size += 1 * this->channel_colors_size();
  for (int i = 0; i < this->channel_colors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->channel_colors(i));
  }

  // repeated int32 freespace_channels = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->freespace_channels_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->freespace_channels(i));
    }
    total_size += 1 * this->freespace_channels_size() + data_size;
  }

  // repeated int32 boundspace_channels = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->boundspace_channels_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->boundspace_channels(i));
    }
    total_size += 1 * this->boundspace_channels_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParsingSetting::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ParsingSetting* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ParsingSetting*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ParsingSetting::MergeFrom(const ParsingSetting& from) {
  GOOGLE_CHECK_NE(&from, this);
  channel_labels_.MergeFrom(from.channel_labels_);
  channel_colors_.MergeFrom(from.channel_colors_);
  freespace_channels_.MergeFrom(from.freespace_channels_);
  boundspace_channels_.MergeFrom(from.boundspace_channels_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_parsing_type()) {
      set_parsing_type(from.parsing_type());
    }
    if (from.has_parsing_channels()) {
      set_parsing_channels(from.parsing_channels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ParsingSetting::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParsingSetting::CopyFrom(const ParsingSetting& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParsingSetting::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->channel_colors())) return false;
  return true;
}

void ParsingSetting::Swap(ParsingSetting* other) {
  if (other != this) {
    std::swap(parsing_type_, other->parsing_type_);
    std::swap(parsing_channels_, other->parsing_channels_);
    channel_labels_.Swap(&other->channel_labels_);
    channel_colors_.Swap(&other->channel_colors_);
    freespace_channels_.Swap(&other->freespace_channels_);
    boundspace_channels_.Swap(&other->boundspace_channels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ParsingSetting::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ParsingSetting_descriptor_;
  metadata.reflection = ParsingSetting_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CommonProto

// @@protoc_insertion_point(global_scope)
